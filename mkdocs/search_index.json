{
    "docs": [
        {
            "location": "/", 
            "text": "LuaCML\n\n\nOverview\n\n\nLuaCML is an implementation of the CML library to be used in Lua applications.\nIt works as a Lua module that can be loaded using the \nrequire\n function:\n\n\n-- Load the LuaCML library.\nlocal luacml = require(\nluacml\n)\n\n\n\n\nor\n\n\n-- Only load portions of the LuaCML library.\nlocal vec2 = require(\nluacml.vector2\n)\nlocal vec3 = require(\nluacml.vector3\n)\nlocal vec4 = require(\nluacml.vector4\n)\nlocal quat = require(\nluacml.quat_p\n)\n\n\n\n\nFeatures\n\n\nThere are a number of predefined types available:\n\n\n\n\nVector types\n\n\nQuaternion types\n\n\nMatrix types\n\n\n\n\nMore detailed documentation exists for various \nlibrary functions\n.\n\n\nDesign decisions\n\n\nSince CML is a library based on C++ templates, LuaCML is unable to provide the\nsame configurability and instead aims to provide only the most common types.\n\n\nLuaCML also chooses to base the floating point math types around the built-in\n\nlua_Number\n type.\n\n\nInteger types \n(See Lua 5.3)\n is not currently supported, nor planned.\n\n\nDynamic types (vectors of size \n 4, matrices \n 4x4) are not currently supported,\nnor planned.\n\n\nCompatibility\n\n\n\n\n\n\n\n\nLua Version\n\n\nSupported\n\n\n\n\n\n\n\n\n\n\nPUC-Rio Lua 5.1\n\n\nyes\n\n\n\n\n\n\nPUC-Rio Lua 5.2\n\n\nyes\n\n\n\n\n\n\nPUC-Rio Lua 5.3\n\n\nyes\n\n\n\n\n\n\nLuaJit 2.0\n\n\nyes\n\n\n\n\n\n\nLuaJit 2.1\n\n\nyes", 
            "title": "Home"
        }, 
        {
            "location": "/#luacml", 
            "text": "", 
            "title": "LuaCML"
        }, 
        {
            "location": "/#overview", 
            "text": "LuaCML is an implementation of the CML library to be used in Lua applications.\nIt works as a Lua module that can be loaded using the  require  function:  -- Load the LuaCML library.\nlocal luacml = require( luacml )  or  -- Only load portions of the LuaCML library.\nlocal vec2 = require( luacml.vector2 )\nlocal vec3 = require( luacml.vector3 )\nlocal vec4 = require( luacml.vector4 )\nlocal quat = require( luacml.quat_p )", 
            "title": "Overview"
        }, 
        {
            "location": "/#features", 
            "text": "There are a number of predefined types available:   Vector types  Quaternion types  Matrix types   More detailed documentation exists for various  library functions .", 
            "title": "Features"
        }, 
        {
            "location": "/#design-decisions", 
            "text": "Since CML is a library based on C++ templates, LuaCML is unable to provide the\nsame configurability and instead aims to provide only the most common types.  LuaCML also chooses to base the floating point math types around the built-in lua_Number  type.  Integer types  (See Lua 5.3)  is not currently supported, nor planned.  Dynamic types (vectors of size   4, matrices   4x4) are not currently supported,\nnor planned.", 
            "title": "Design decisions"
        }, 
        {
            "location": "/#compatibility", 
            "text": "Lua Version  Supported      PUC-Rio Lua 5.1  yes    PUC-Rio Lua 5.2  yes    PUC-Rio Lua 5.3  yes    LuaJit 2.0  yes    LuaJit 2.1  yes", 
            "title": "Compatibility"
        }, 
        {
            "location": "/library-docs/", 
            "text": "Library Functions\n\n\n\n\ndot()\n\n\nThe dot product can be performed for vector and quaternion types.\n\n\nlocal foo = luacml.vector3(1,2,3)\nlocal bar = luacml.vector3(1,2,3)\nprint(luacml.dot(foo, bar)) -- prints: 14\n\n\n\n\nNote\n\n\nOnly the following types are supported:\n\n\nVectors\n: \nvector2\n, \nvector3\n, \nvector4\n\n\nQuaternions\n: \nquat\n, \nquat_p\n, \nquat_n\n\n\nParameters\n\n\n\n\n2 vectors of same type.\n\n\nor 2 quaternions of same type.\n\n\n\n\nReturns\n\n\nReturns the dot product as a number.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\ncross()\n\n\nThe cross product can be performed for the \nvector3\n type.\n\n\nlocal foo = luacml.vector3(1,2,3)\nlocal bar = luacml.vector3(3,2,1)\nprint(luacml.cross(foo, bar)) -- prints: vector3:\n-4,8,-4\n\n\n\n\n\nNote\n\n\nOnly the \nvector3\n type supports cross product.\n\n\nParameters\n\n\n\n\n2 vectors of type \nvector3\n.\n\n\n\n\nReturns\n\n\nReturns the cross product as a \nvector3\n.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\nouter()\n\n\nThe outer product can be performed for vector types.\n\n\nlocal foo = luacml.vector3(1,2,3)\nlocal bar = luacml.vector3(3,2,1)\nprint(luacml.outer(foo, bar)) -- prints: matrix33:|3,2,1|6,4,2|9,6,3|\n\n\n\n\nNote\n\n\nOnly the following types are supported:\n\n\nVectors\n: \nvector2\n, \nvector3\n, \nvector4\n\n\nParameters\n\n\n\n\n2 vectors of same type.\n\n\n\n\nReturns\n\n\nReturns the outer product as a matrix of size \nNxN\n for vectors of size \nN\n.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\nperp_dot()\n\n\nThe perpendicular dot product can be performed for Vector2.\n\n\nlocal left = luacml.vector2(1,2)\nlocal right = luacml.vector2(3,4)\nprint(luacml.perp_dot(left, right)) -- prints: -2\n\n\n\n\nNote\n\n\nOnly the \nvector2\n type is supported.\n\n\nThe result is the dot product of \nright\n and the perpendicular vector to \nleft\n.\n\n\nParameters\n\n\n\n\n2 \nvector2\n.\n\n\n\n\nReturns\n\n\nReturns the perpendicular dot product of the two input vectors.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\ntriple_product()\n\n\nThe triple product can be performed for three \nvector3\n objects.\n\n\nlocal A = luacml.vector3(1,2,3)\nlocal B = luacml.vector3(4,5,6)\nlocal C = luacml.vector3(7,8,9)\nprint(luacml.triple_product(A, B, C)) -- prints: 0\n\n\n\n\nNote\n\n\nOnly the \nvector3\n type is supported.\n\n\nThe result is equivalent to\n\n\nluacml.dot(A, luacml.cross(B,C))\n\n\n\n\nParameters\n\n\n\n\n3 \nvector3\n.\n\n\n\n\nReturns\n\n\nReturns the triple product of the three input vectors.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\nunit_cross()\n\n\nThe normalized cross product between two \nvector3\n:\n\n\nlocal A = luacml.vector3(10,0,0)\nlocal B = luacml.vector3(0,10,0)\nprint(luacml.unit_cross(A, B)) -- prints: vector3:\n0,0,1\n\n\n\n\n\nNote\n\n\nOnly the \nvector3\n type is supported.\n\n\nThe result is equivalent to\n\n\nluacml.cross(B,C):normalize()\n\n\n\n\nParameters\n\n\n\n\n3 \nvector3\n.\n\n\n\n\nReturns\n\n\nReturns the normalized cross product of the two input vectors.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.", 
            "title": "Library docs"
        }, 
        {
            "location": "/library-docs/#library-functions", 
            "text": "", 
            "title": "Library Functions"
        }, 
        {
            "location": "/library-docs/#dot", 
            "text": "The dot product can be performed for vector and quaternion types.  local foo = luacml.vector3(1,2,3)\nlocal bar = luacml.vector3(1,2,3)\nprint(luacml.dot(foo, bar)) -- prints: 14", 
            "title": "dot()"
        }, 
        {
            "location": "/library-docs/#note", 
            "text": "Only the following types are supported:  Vectors :  vector2 ,  vector3 ,  vector4  Quaternions :  quat ,  quat_p ,  quat_n", 
            "title": "Note"
        }, 
        {
            "location": "/library-docs/#parameters", 
            "text": "2 vectors of same type.  or 2 quaternions of same type.", 
            "title": "Parameters"
        }, 
        {
            "location": "/library-docs/#returns", 
            "text": "Returns the dot product as a number.", 
            "title": "Returns"
        }, 
        {
            "location": "/library-docs/#errors", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/library-docs/#cross", 
            "text": "The cross product can be performed for the  vector3  type.  local foo = luacml.vector3(1,2,3)\nlocal bar = luacml.vector3(3,2,1)\nprint(luacml.cross(foo, bar)) -- prints: vector3: -4,8,-4", 
            "title": "cross()"
        }, 
        {
            "location": "/library-docs/#note_1", 
            "text": "Only the  vector3  type supports cross product.", 
            "title": "Note"
        }, 
        {
            "location": "/library-docs/#parameters_1", 
            "text": "2 vectors of type  vector3 .", 
            "title": "Parameters"
        }, 
        {
            "location": "/library-docs/#returns_1", 
            "text": "Returns the cross product as a  vector3 .", 
            "title": "Returns"
        }, 
        {
            "location": "/library-docs/#errors_1", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/library-docs/#outer", 
            "text": "The outer product can be performed for vector types.  local foo = luacml.vector3(1,2,3)\nlocal bar = luacml.vector3(3,2,1)\nprint(luacml.outer(foo, bar)) -- prints: matrix33:|3,2,1|6,4,2|9,6,3|", 
            "title": "outer()"
        }, 
        {
            "location": "/library-docs/#note_2", 
            "text": "Only the following types are supported:  Vectors :  vector2 ,  vector3 ,  vector4", 
            "title": "Note"
        }, 
        {
            "location": "/library-docs/#parameters_2", 
            "text": "2 vectors of same type.", 
            "title": "Parameters"
        }, 
        {
            "location": "/library-docs/#returns_2", 
            "text": "Returns the outer product as a matrix of size  NxN  for vectors of size  N .", 
            "title": "Returns"
        }, 
        {
            "location": "/library-docs/#errors_2", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/library-docs/#perp_dot", 
            "text": "The perpendicular dot product can be performed for Vector2.  local left = luacml.vector2(1,2)\nlocal right = luacml.vector2(3,4)\nprint(luacml.perp_dot(left, right)) -- prints: -2", 
            "title": "perp_dot()"
        }, 
        {
            "location": "/library-docs/#note_3", 
            "text": "Only the  vector2  type is supported.  The result is the dot product of  right  and the perpendicular vector to  left .", 
            "title": "Note"
        }, 
        {
            "location": "/library-docs/#parameters_3", 
            "text": "2  vector2 .", 
            "title": "Parameters"
        }, 
        {
            "location": "/library-docs/#returns_3", 
            "text": "Returns the perpendicular dot product of the two input vectors.", 
            "title": "Returns"
        }, 
        {
            "location": "/library-docs/#errors_3", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/library-docs/#triple_product", 
            "text": "The triple product can be performed for three  vector3  objects.  local A = luacml.vector3(1,2,3)\nlocal B = luacml.vector3(4,5,6)\nlocal C = luacml.vector3(7,8,9)\nprint(luacml.triple_product(A, B, C)) -- prints: 0", 
            "title": "triple_product()"
        }, 
        {
            "location": "/library-docs/#note_4", 
            "text": "Only the  vector3  type is supported.  The result is equivalent to  luacml.dot(A, luacml.cross(B,C))", 
            "title": "Note"
        }, 
        {
            "location": "/library-docs/#parameters_4", 
            "text": "3  vector3 .", 
            "title": "Parameters"
        }, 
        {
            "location": "/library-docs/#returns_4", 
            "text": "Returns the triple product of the three input vectors.", 
            "title": "Returns"
        }, 
        {
            "location": "/library-docs/#errors_4", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/library-docs/#unit_cross", 
            "text": "The normalized cross product between two  vector3 :  local A = luacml.vector3(10,0,0)\nlocal B = luacml.vector3(0,10,0)\nprint(luacml.unit_cross(A, B)) -- prints: vector3: 0,0,1", 
            "title": "unit_cross()"
        }, 
        {
            "location": "/library-docs/#note_5", 
            "text": "Only the  vector3  type is supported.  The result is equivalent to  luacml.cross(B,C):normalize()", 
            "title": "Note"
        }, 
        {
            "location": "/library-docs/#parameters_5", 
            "text": "3  vector3 .", 
            "title": "Parameters"
        }, 
        {
            "location": "/library-docs/#returns_5", 
            "text": "Returns the normalized cross product of the two input vectors.", 
            "title": "Returns"
        }, 
        {
            "location": "/library-docs/#errors_5", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-docs/", 
            "text": "Matrices\n\n\nMatrix types\n\n\nThe following vector types are provided by LuaCML:\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmatrix22\n\n\nA 2x2 row major, column basis matrix based on \nlua_Number\n\n\n\n\n\n\nmatrix22_c\n\n\nA 2x2 column major, column basis matrix based on \nlua_Number\n\n\n\n\n\n\nmatrix22_r\n\n\nA 2x2 row major, row basis matrix based on \nlua_Number\n\n\n\n\n\n\nmatrix33\n\n\nA 3x3 row major, column basis matrix based on \nlua_Number\n\n\n\n\n\n\nmatrix33_c\n\n\nA 3x3 column major, column basis matrix based on \nlua_Number\n\n\n\n\n\n\nmatrix33_r\n\n\nA 3x3 row major, row basis matrix based on \nlua_Number\n\n\n\n\n\n\nmatrix44\n\n\nA 4x4 row major, column basis matrix based on \nlua_Number\n\n\n\n\n\n\nmatrix44_c\n\n\nA 4x4 column major, column basis matrix based on \nlua_Number\n\n\n\n\n\n\nmatrix44_r\n\n\nA 4x4 row major, row basis matrix based on \nlua_Number\n\n\n\n\n\n\nmatrix23_c\n\n\nA 2x3 column major, column basis matrix based on \nlua_Number\n\n\n\n\n\n\nmatrix32_r\n\n\nA 3x2 row major, row basis matrix based on \nlua_Number\n\n\n\n\n\n\nmatrix34_c\n\n\nA 3x4 column major, column basis matrix based on \nlua_Number\n\n\n\n\n\n\nmatrix43_r\n\n\nA 4x3 row major, row basis matrix based on \nlua_Number\n\n\n\n\n\n\n\n\nMatrix functions\n\n\nconstructor\n\n\nMatrices have default constructors, initialized with identity:\n\n\nlocal foo = luacml.matrix22()\n-- Set to: |1 0|\n--         |0 1|\n\n\n\n\nMatrices can be constructed from individual numbers:\n\n\nlocal foo = luacml.matrix33(1,2,3,4,5,6,7,8,9)\n-- Set to: |1 2 3|\n--         |4 5 6|\n--         |7 8 9|\n\n\n\n\nOr from a table of numbers:\n\n\nlocal foo = luacml.matrix22({1,2,3,4})\n-- Set to: |1 2|\n--         |3 4|\n\n\n\n\nOr from another matrix:\n\n\nlocal foo = luacml.matrix22(1,2,3,4)\nlocal bar = luacml.matrix22(foo)\n-- Set to: |1 2|\n--         |3 4|\n\n\n\n\nParameters\n\n\n\n\nN\n numbers, where N is the number of rows times the number of columns.\n\n\nor a table of \nN\n numbers, where N is the number of rows times the number\n    of columns.\n\n\nor a matrix of same type.\n\n\n\n\nReturns\n\n\nThe newly constructed matrix.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\ntotable()\n\n\nMatrices can be converted to a table:\n\n\nlocal foo = luacml.matrix33(1,2,3,4,5,6,7,8,9)\nlocal bar = foo:totable()\nprint(bar[1], bar[2], bar[3]) -- prints: 1 2 3\n\n\n\n\nParameters\n\n\n(None)\n\n\nReturns\n\n\nAn array containing the matrix's elements.\n\n\nErrors\n\n\n\n\nExtra arguments.\n\n\n\n\n\n\nset()\n\n\nMatrices can be set from individual numbers:\n\n\nlocal foo = luacml.matrix33()\nfoo:set(1,2,3,4,5,6,7,8,9)\n\n\n\n\nOr from a table of numbers:\n\n\nlocal foo = luacml.matrix33()\nfoo:set({1,2,3,4,5,6,7,8,9})\n\n\n\n\nOr from another matrix:\n\n\nlocal foo = luacml.matrix33()\nfoo:set(luacml.matrix33(1,2,3,4,5,6,7,8,9))\n\n\n\n\nParameters\n\n\n\n\nN\n numbers, where N is the number of rows times the number of columns.\n\n\nor a table of \nN\n numbers, where N is the number of rows times the number\n    of columns.\n\n\nor a matrix of same type.\n\n\n\n\nReturns\n\n\nThe matrix, after it has been set.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\nidentity()\n\n\nA matrix can be set to identity in-place:\n\n\nlocal foo = luacml.matrix33(1,2,3,4,5,6,7,8,9)\nfoo:identity()\n-- Set to: |1 0 0|\n--         |0 1 0|\n--         |0 0 1|\n\n\n\n\nlocal foo = luacml.matrix23_c(1,2,3,4,5,6)\nfoo:identity()\n-- Set to: |1 0 0|\n--         |0 1 0|\n\n\n\n\nParameters\n\n\n(None)\n\n\nReturns\n\n\nThe matrix, after it has been set.\n\n\nErrors\n\n\n\n\nExtra arguments.\n\n\n\n\n\n\nzero()\n\n\nA matrix can be set to zero in-place:\n\n\nlocal foo = luacml.matrix33(1,2,3,4,5,6,7,8,9)\nfoo:zero()\n-- Set to: |0 0 0|\n--         |0 0 0|\n--         |0 0 0|\n\n\n\n\nlocal foo = luacml.matrix23_c(1,2,3,4,5,6)\nfoo:zero()\n-- Set to: |0 0 0|\n--         |0 0 0|\n\n\n\n\nParameters\n\n\n(None)\n\n\nReturns\n\n\nThe matrix, after it has been zeroed.\n\n\nErrors\n\n\n\n\nExtra arguments.\n\n\n\n\n\n\nrows()\n\n\nThe number of rows for a matrix can be read:\n\n\nlocal foo = luacml.matrix33()\nprint(foo:rows()) -- Prints: 3\n\n\n\n\nlocal foo = luacml.matrix23_c()\nprint(foo:rows()) -- Prints: 2\n\n\n\n\nParameters\n\n\n(None)\n\n\nReturns\n\n\nThe number of matrix rows, as an integer.\n\n\nErrors\n\n\n\n\nExtra arguments.\n\n\n\n\n\n\ncols()\n\n\nThe number of columns for a matrix can be read:\n\n\nlocal foo = luacml.matrix33()\nprint(foo:cols()) -- Prints: 3\n\n\n\n\nlocal foo = luacml.matrix23_c()\nprint(foo:cols()) -- Prints: 3\n\n\n\n\nParameters\n\n\n(None)\n\n\nReturns\n\n\nThe number of matrix columns, as an integer.\n\n\nErrors\n\n\n\n\nExtra arguments.\n\n\n\n\n\n\ntranspose()\n\n\nA square matrix can be transposed:\n\n\nlocal foo = luacml.matrix33(1,2,3,4,5,6,7,8,9)\nfoo:transpose()\n-- Set to: |1 4 7|\n--         |2 5 8|\n--         |3 6 9|\n\n\n\n\nNote\n\n\nOnly square matrices have this function. Calling it with a non-square matrix\nwill throw an error.\n\n\nParameters\n\n\n(None)\n\n\nReturns\n\n\nThe matrix after it has been transposed.\n\n\nErrors\n\n\n\n\nExtra arguments.\n\n\n\n\n\n\nMatrix metamethods\n\n\nAll matrix types have a set of\n\nmetamethods\n that allow them to\nbe used with several operators.\n\n\n\n\n__tostring\n\n\nMatrices can be converted to strings for easy printing.\n\n\nlocal foo = luacml.matrix33(1,2,3,4,5,6,7,8,9)\nprint(foo) -- prints: matrix33:|1,2,3|4,5,6|7,8,9|\n\n\n\n\nlocal foo = luacml.matrix23_c(1,2,3,4,5,6)\nprint(foo) -- prints: matrix23_c:|1,2,3|4,5,6|\n\n\n\n\nNote\n\n\nThis function internally uses \nlua_pushfstring\n to format the output, so be\naware of slightly different formatting across versions of Lua.\n\n\nParameters\n\n\nA matrix.\n\n\nReturns\n\n\nThe matrix formatted as a string.\n\n\nErrors\n\n\n(None)\n\n\n\n\n__index\n\n\nThe __index metamethod permits vector element access.\n\n\nMatrices can be indexed with 1-based integer keys (1 through \nN\n, where N is\nnumber of rows times the number of columns):\n\n\nlocal foo = luacml.matrix22(10,20,30,40)\nprint(foo[1],foo[2],foo[3],foo[4]) -- prints: 10 20 30 40\n\n\n\n\nOr with case-insensitive \"mRC\" string keys, where R is the row number, and C is\nthe column number:\n\n\nlocal foo = luacml.matrix22(10,20,30,40)\nprint(foo.m11, foo.m12, foo.m21, foo.m22) -- prints: 10 20 30 40\n\n\n\n\nNote\n\n\nThe \nmatrix22\n, \nmatrix22_c\n and \nmatrix22_r\n types use the following indices\nand mappings:\n\n\n| 1 | 2 |\n| 3 | 4 |\n\n\n\n\nor\n\n\n| m11 | m12 |\n| m21 | m22 |\n\n\n\n\nThe \nmatrix33\n, \nmatrix33_c\n and \nmatrix33_r\n types use the following indices\nand mappings:\n\n\n| 1 | 2 | 3 |\n| 4 | 5 | 6 |\n| 7 | 8 | 9 |\n\n\n\n\nor\n\n\n| m11 | m12 | m13 |\n| m21 | m22 | m23 |\n| m31 | m32 | m33 |\n\n\n\n\nThe \nmatrix44\n, \nmatrix44_c\n and \nmatrix44_r\n types use the following indices\nand mappings:\n\n\n|  1 |  2 |  3 |  4 |\n|  5 |  6 |  7 |  8 |\n|  9 | 10 | 11 | 12 |\n| 13 | 14 | 15 | 16 |\n\n\n\n\nor\n\n\n| m11 | m12 | m13 | m14 |\n| m21 | m22 | m23 | m24 |\n| m31 | m32 | m33 | m34 |\n| m41 | m42 | m43 | m44 |\n\n\n\n\nThe \nmatrix23_c\n type uses the following indices and map:\n\n\n| 1 | 2 | 3 |\n| 4 | 5 | 6 |\n\n\n\n\nor\n\n\n| m11 | m12 | m13 |\n| m21 | m22 | m23 |\n\n\n\n\nThe \nmatrix32_r\n type uses the following indices and map:\n\n\n| 1 | 2 |\n| 3 | 4 |\n| 5 | 6 |\n\n\n\n\nor\n\n\n| m11 | m12 |\n| m21 | m22 |\n| m31 | m32 |\n\n\n\n\nThe \nmatrix34_c\n type uses the following indices and map:\n\n\n|  1 |  2 |  3 |  4 |\n|  5 |  6 |  7 |  8 |\n|  9 | 10 | 11 | 12 |\n\n\n\n\nor\n\n\n| m11 | m12 | m13 | m14 |\n| m21 | m22 | m23 | m24 |\n| m31 | m32 | m33 | m34 |\n\n\n\n\nThe \nmatrix43_r\n type uses the following indices and map:\n\n\n|  1 |  2 |  3 |\n|  4 |  5 |  6 |\n|  7 |  8 |  9 |\n| 10 | 11 | 12 |\n\n\n\n\nor\n\n\n| m11 | m12 | m13 |\n| m21 | m22 | m23 |\n| m31 | m32 | m33 |\n| m41 | m42 | m43 |\n\n\n\n\nParameters\n\n\n\n\nAn integer from 1 to \nN\n, where N is the number of rows times the number\n    of columns.\n\n\nor one of the string keys following the \"mRC\" convention (ie \"m12\" for the\n    element in the first row, second column).\n\n\n\n\nReturns\n\n\nThe matrix's element as a number.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nInvalid index value.\n\n\nInvalid index type.\n\n\n\n\n\n\n__newindex\n\n\nThe __newindex metamethod permits matrix element setting.\n\n\nMatrices can be indexed with 1-based integer keys:\n\n\nlocal foo = luacml.matrix22()\nfoo[1] = 10\nfoo[2] = 20\nfoo[3] = 30\nfoo[4] = 40\n-- Sets to: | 10 20 |\n--          | 30 40 |\n\n\n\n\nOr with case-insensitive \"mRC\" string keys:\n\n\nlocal foo = luacml.matrix22()\nfoo.m11 = 10\nfoo.m12 = 20\nfoo.m21 = 30\nfoo.m22 = 40\n-- Sets to: | 10 20 |\n--          | 30 40 |\n\n\n\n\nNote\n\n\nSee Note for \n__index\n about valid keys for each type of matrix.\n\n\nParameters\n\n\n\n\nAn integer from 1 to \nN\n, where N is the number of rows times the number\n    of columns.\n\n\nor one of the string keys following the \"mRC\" convention (ie \"m12\" for the\n    element in the first row, second column).\n\n\n\n\nReturns\n\n\n(None)\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nInvalid index value.\n\n\nInvalid index type.", 
            "title": "Matrix docs"
        }, 
        {
            "location": "/matrix-docs/#matrices", 
            "text": "", 
            "title": "Matrices"
        }, 
        {
            "location": "/matrix-docs/#matrix-types", 
            "text": "The following vector types are provided by LuaCML:     Type  Description      matrix22  A 2x2 row major, column basis matrix based on  lua_Number    matrix22_c  A 2x2 column major, column basis matrix based on  lua_Number    matrix22_r  A 2x2 row major, row basis matrix based on  lua_Number    matrix33  A 3x3 row major, column basis matrix based on  lua_Number    matrix33_c  A 3x3 column major, column basis matrix based on  lua_Number    matrix33_r  A 3x3 row major, row basis matrix based on  lua_Number    matrix44  A 4x4 row major, column basis matrix based on  lua_Number    matrix44_c  A 4x4 column major, column basis matrix based on  lua_Number    matrix44_r  A 4x4 row major, row basis matrix based on  lua_Number    matrix23_c  A 2x3 column major, column basis matrix based on  lua_Number    matrix32_r  A 3x2 row major, row basis matrix based on  lua_Number    matrix34_c  A 3x4 column major, column basis matrix based on  lua_Number    matrix43_r  A 4x3 row major, row basis matrix based on  lua_Number", 
            "title": "Matrix types"
        }, 
        {
            "location": "/matrix-docs/#matrix-functions", 
            "text": "", 
            "title": "Matrix functions"
        }, 
        {
            "location": "/matrix-docs/#constructor", 
            "text": "Matrices have default constructors, initialized with identity:  local foo = luacml.matrix22()\n-- Set to: |1 0|\n--         |0 1|  Matrices can be constructed from individual numbers:  local foo = luacml.matrix33(1,2,3,4,5,6,7,8,9)\n-- Set to: |1 2 3|\n--         |4 5 6|\n--         |7 8 9|  Or from a table of numbers:  local foo = luacml.matrix22({1,2,3,4})\n-- Set to: |1 2|\n--         |3 4|  Or from another matrix:  local foo = luacml.matrix22(1,2,3,4)\nlocal bar = luacml.matrix22(foo)\n-- Set to: |1 2|\n--         |3 4|", 
            "title": "constructor"
        }, 
        {
            "location": "/matrix-docs/#parameters", 
            "text": "N  numbers, where N is the number of rows times the number of columns.  or a table of  N  numbers, where N is the number of rows times the number\n    of columns.  or a matrix of same type.", 
            "title": "Parameters"
        }, 
        {
            "location": "/matrix-docs/#returns", 
            "text": "The newly constructed matrix.", 
            "title": "Returns"
        }, 
        {
            "location": "/matrix-docs/#errors", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-docs/#totable", 
            "text": "Matrices can be converted to a table:  local foo = luacml.matrix33(1,2,3,4,5,6,7,8,9)\nlocal bar = foo:totable()\nprint(bar[1], bar[2], bar[3]) -- prints: 1 2 3", 
            "title": "totable()"
        }, 
        {
            "location": "/matrix-docs/#parameters_1", 
            "text": "(None)", 
            "title": "Parameters"
        }, 
        {
            "location": "/matrix-docs/#returns_1", 
            "text": "An array containing the matrix's elements.", 
            "title": "Returns"
        }, 
        {
            "location": "/matrix-docs/#errors_1", 
            "text": "Extra arguments.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-docs/#set", 
            "text": "Matrices can be set from individual numbers:  local foo = luacml.matrix33()\nfoo:set(1,2,3,4,5,6,7,8,9)  Or from a table of numbers:  local foo = luacml.matrix33()\nfoo:set({1,2,3,4,5,6,7,8,9})  Or from another matrix:  local foo = luacml.matrix33()\nfoo:set(luacml.matrix33(1,2,3,4,5,6,7,8,9))", 
            "title": "set()"
        }, 
        {
            "location": "/matrix-docs/#parameters_2", 
            "text": "N  numbers, where N is the number of rows times the number of columns.  or a table of  N  numbers, where N is the number of rows times the number\n    of columns.  or a matrix of same type.", 
            "title": "Parameters"
        }, 
        {
            "location": "/matrix-docs/#returns_2", 
            "text": "The matrix, after it has been set.", 
            "title": "Returns"
        }, 
        {
            "location": "/matrix-docs/#errors_2", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-docs/#identity", 
            "text": "A matrix can be set to identity in-place:  local foo = luacml.matrix33(1,2,3,4,5,6,7,8,9)\nfoo:identity()\n-- Set to: |1 0 0|\n--         |0 1 0|\n--         |0 0 1|  local foo = luacml.matrix23_c(1,2,3,4,5,6)\nfoo:identity()\n-- Set to: |1 0 0|\n--         |0 1 0|", 
            "title": "identity()"
        }, 
        {
            "location": "/matrix-docs/#parameters_3", 
            "text": "(None)", 
            "title": "Parameters"
        }, 
        {
            "location": "/matrix-docs/#returns_3", 
            "text": "The matrix, after it has been set.", 
            "title": "Returns"
        }, 
        {
            "location": "/matrix-docs/#errors_3", 
            "text": "Extra arguments.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-docs/#zero", 
            "text": "A matrix can be set to zero in-place:  local foo = luacml.matrix33(1,2,3,4,5,6,7,8,9)\nfoo:zero()\n-- Set to: |0 0 0|\n--         |0 0 0|\n--         |0 0 0|  local foo = luacml.matrix23_c(1,2,3,4,5,6)\nfoo:zero()\n-- Set to: |0 0 0|\n--         |0 0 0|", 
            "title": "zero()"
        }, 
        {
            "location": "/matrix-docs/#parameters_4", 
            "text": "(None)", 
            "title": "Parameters"
        }, 
        {
            "location": "/matrix-docs/#returns_4", 
            "text": "The matrix, after it has been zeroed.", 
            "title": "Returns"
        }, 
        {
            "location": "/matrix-docs/#errors_4", 
            "text": "Extra arguments.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-docs/#rows", 
            "text": "The number of rows for a matrix can be read:  local foo = luacml.matrix33()\nprint(foo:rows()) -- Prints: 3  local foo = luacml.matrix23_c()\nprint(foo:rows()) -- Prints: 2", 
            "title": "rows()"
        }, 
        {
            "location": "/matrix-docs/#parameters_5", 
            "text": "(None)", 
            "title": "Parameters"
        }, 
        {
            "location": "/matrix-docs/#returns_5", 
            "text": "The number of matrix rows, as an integer.", 
            "title": "Returns"
        }, 
        {
            "location": "/matrix-docs/#errors_5", 
            "text": "Extra arguments.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-docs/#cols", 
            "text": "The number of columns for a matrix can be read:  local foo = luacml.matrix33()\nprint(foo:cols()) -- Prints: 3  local foo = luacml.matrix23_c()\nprint(foo:cols()) -- Prints: 3", 
            "title": "cols()"
        }, 
        {
            "location": "/matrix-docs/#parameters_6", 
            "text": "(None)", 
            "title": "Parameters"
        }, 
        {
            "location": "/matrix-docs/#returns_6", 
            "text": "The number of matrix columns, as an integer.", 
            "title": "Returns"
        }, 
        {
            "location": "/matrix-docs/#errors_6", 
            "text": "Extra arguments.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-docs/#transpose", 
            "text": "A square matrix can be transposed:  local foo = luacml.matrix33(1,2,3,4,5,6,7,8,9)\nfoo:transpose()\n-- Set to: |1 4 7|\n--         |2 5 8|\n--         |3 6 9|", 
            "title": "transpose()"
        }, 
        {
            "location": "/matrix-docs/#note", 
            "text": "Only square matrices have this function. Calling it with a non-square matrix\nwill throw an error.", 
            "title": "Note"
        }, 
        {
            "location": "/matrix-docs/#parameters_7", 
            "text": "(None)", 
            "title": "Parameters"
        }, 
        {
            "location": "/matrix-docs/#returns_7", 
            "text": "The matrix after it has been transposed.", 
            "title": "Returns"
        }, 
        {
            "location": "/matrix-docs/#errors_7", 
            "text": "Extra arguments.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-docs/#matrix-metamethods", 
            "text": "All matrix types have a set of metamethods  that allow them to\nbe used with several operators.", 
            "title": "Matrix metamethods"
        }, 
        {
            "location": "/matrix-docs/#__tostring", 
            "text": "Matrices can be converted to strings for easy printing.  local foo = luacml.matrix33(1,2,3,4,5,6,7,8,9)\nprint(foo) -- prints: matrix33:|1,2,3|4,5,6|7,8,9|  local foo = luacml.matrix23_c(1,2,3,4,5,6)\nprint(foo) -- prints: matrix23_c:|1,2,3|4,5,6|", 
            "title": "__tostring"
        }, 
        {
            "location": "/matrix-docs/#note_1", 
            "text": "This function internally uses  lua_pushfstring  to format the output, so be\naware of slightly different formatting across versions of Lua.", 
            "title": "Note"
        }, 
        {
            "location": "/matrix-docs/#parameters_8", 
            "text": "A matrix.", 
            "title": "Parameters"
        }, 
        {
            "location": "/matrix-docs/#returns_8", 
            "text": "The matrix formatted as a string.", 
            "title": "Returns"
        }, 
        {
            "location": "/matrix-docs/#errors_8", 
            "text": "(None)", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-docs/#__index", 
            "text": "The __index metamethod permits vector element access.  Matrices can be indexed with 1-based integer keys (1 through  N , where N is\nnumber of rows times the number of columns):  local foo = luacml.matrix22(10,20,30,40)\nprint(foo[1],foo[2],foo[3],foo[4]) -- prints: 10 20 30 40  Or with case-insensitive \"mRC\" string keys, where R is the row number, and C is\nthe column number:  local foo = luacml.matrix22(10,20,30,40)\nprint(foo.m11, foo.m12, foo.m21, foo.m22) -- prints: 10 20 30 40", 
            "title": "__index"
        }, 
        {
            "location": "/matrix-docs/#note_2", 
            "text": "The  matrix22 ,  matrix22_c  and  matrix22_r  types use the following indices\nand mappings:  | 1 | 2 |\n| 3 | 4 |  or  | m11 | m12 |\n| m21 | m22 |  The  matrix33 ,  matrix33_c  and  matrix33_r  types use the following indices\nand mappings:  | 1 | 2 | 3 |\n| 4 | 5 | 6 |\n| 7 | 8 | 9 |  or  | m11 | m12 | m13 |\n| m21 | m22 | m23 |\n| m31 | m32 | m33 |  The  matrix44 ,  matrix44_c  and  matrix44_r  types use the following indices\nand mappings:  |  1 |  2 |  3 |  4 |\n|  5 |  6 |  7 |  8 |\n|  9 | 10 | 11 | 12 |\n| 13 | 14 | 15 | 16 |  or  | m11 | m12 | m13 | m14 |\n| m21 | m22 | m23 | m24 |\n| m31 | m32 | m33 | m34 |\n| m41 | m42 | m43 | m44 |  The  matrix23_c  type uses the following indices and map:  | 1 | 2 | 3 |\n| 4 | 5 | 6 |  or  | m11 | m12 | m13 |\n| m21 | m22 | m23 |  The  matrix32_r  type uses the following indices and map:  | 1 | 2 |\n| 3 | 4 |\n| 5 | 6 |  or  | m11 | m12 |\n| m21 | m22 |\n| m31 | m32 |  The  matrix34_c  type uses the following indices and map:  |  1 |  2 |  3 |  4 |\n|  5 |  6 |  7 |  8 |\n|  9 | 10 | 11 | 12 |  or  | m11 | m12 | m13 | m14 |\n| m21 | m22 | m23 | m24 |\n| m31 | m32 | m33 | m34 |  The  matrix43_r  type uses the following indices and map:  |  1 |  2 |  3 |\n|  4 |  5 |  6 |\n|  7 |  8 |  9 |\n| 10 | 11 | 12 |  or  | m11 | m12 | m13 |\n| m21 | m22 | m23 |\n| m31 | m32 | m33 |\n| m41 | m42 | m43 |", 
            "title": "Note"
        }, 
        {
            "location": "/matrix-docs/#parameters_9", 
            "text": "An integer from 1 to  N , where N is the number of rows times the number\n    of columns.  or one of the string keys following the \"mRC\" convention (ie \"m12\" for the\n    element in the first row, second column).", 
            "title": "Parameters"
        }, 
        {
            "location": "/matrix-docs/#returns_9", 
            "text": "The matrix's element as a number.", 
            "title": "Returns"
        }, 
        {
            "location": "/matrix-docs/#errors_9", 
            "text": "Missing arguments.  Invalid index value.  Invalid index type.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-docs/#__newindex", 
            "text": "The __newindex metamethod permits matrix element setting.  Matrices can be indexed with 1-based integer keys:  local foo = luacml.matrix22()\nfoo[1] = 10\nfoo[2] = 20\nfoo[3] = 30\nfoo[4] = 40\n-- Sets to: | 10 20 |\n--          | 30 40 |  Or with case-insensitive \"mRC\" string keys:  local foo = luacml.matrix22()\nfoo.m11 = 10\nfoo.m12 = 20\nfoo.m21 = 30\nfoo.m22 = 40\n-- Sets to: | 10 20 |\n--          | 30 40 |", 
            "title": "__newindex"
        }, 
        {
            "location": "/matrix-docs/#note_3", 
            "text": "See Note for  __index  about valid keys for each type of matrix.", 
            "title": "Note"
        }, 
        {
            "location": "/matrix-docs/#parameters_10", 
            "text": "An integer from 1 to  N , where N is the number of rows times the number\n    of columns.  or one of the string keys following the \"mRC\" convention (ie \"m12\" for the\n    element in the first row, second column).", 
            "title": "Parameters"
        }, 
        {
            "location": "/matrix-docs/#returns_10", 
            "text": "(None)", 
            "title": "Returns"
        }, 
        {
            "location": "/matrix-docs/#errors_10", 
            "text": "Missing arguments.  Invalid index value.  Invalid index type.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/", 
            "text": "Quaternions\n\n\nQuaternion types\n\n\nThe following quaternion types are provided by LuaCML:\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nquat\n\n\nA scalar-first, positive cross quaternion based on \nlua_Number\n\n\n\n\n\n\nquat_p\n\n\nA vector-first, positive cross quaternion based on \nlua_Number\n\n\n\n\n\n\nquat_n\n\n\nA vector-first, negative cross quaternion based on \nlua_Number\n\n\n\n\n\n\n\n\nNote:\n\n\nThe \nquat\n type is a scalar-first quaternion, ie: (w,x,y,z).\n\n\nThe \nquat_p\n and \nquat_n\n types are vector-first quaternions, ie: (x,y,z,w).\n\n\nThe \nquat_p\n (or positive cross) type determines the multiplication order of two\nquaternions in \"standard\" form. A multiplication of \nq1*q2\n represents the\nrotation of \nq2\n applied first, followed by \nq1\n.\n\n\nThe \nquat_n\n (or negative cross) type determines the multiplication order of two\nquaternions in \"reverse\" form. A multiplication of \nq1*q2\n represents the\nrotation of \nq1\n applied first, followed by \nq2\n.\n\n\nQuaternion functions\n\n\nconstructor\n\n\nQuaternions have default constructors initialized with identity:\n\n\nlocal foo = luacml.quat()   -- set to (1,0,0,0)\nlocal bar = luacml.quat_p() -- set to (0,0,0,1)\nlocal baz = luacml.quat_n() -- set to (0,0,0,1)\n\n\n\n\nQuaternions can be constructed from individual numbers:\n\n\nlocal foo = luacml.quat(1,2,3,4)   -- set to (1,2,3,4)\nlocal bar = luacml.quat_p(1,2,3,4) -- set to (1,2,3,4)\nlocal baz = luacml.quat_n(1,2,3,4) -- set to (1,2,3,4)\n\n\n\n\nOr from a table of numbers:\n\n\nlocal foo = luacml.quat({1,2,3,4})   -- set to (1,2,3,4)\nlocal bar = luacml.quat_p({1,2,3,4}) -- set to (1,2,3,4)\nlocal baz = luacml.quat_n({1,2,3,4}) -- set to (1,2,3,4)\n\n\n\n\nOr from a \nvector4\n:\n\n\nlocal foo = luacml.quat(luacml.vector4(1,2,3,4))   -- set to (1,2,3,4)\nlocal bar = luacml.quat_p(luacml.vector4(1,2,3,4)) -- set to (1,2,3,4)\nlocal baz = luacml.quat_n(luacml.vector4(1,2,3,4)) -- set to (1,2,3,4)\n\n\n\n\nOr from a table and a number (or a number and a table):\n\n\nlocal foo = luacml.quat(1, {2,3,4}) -- set to (1,2,3,4)\nlocal bar = luacml.quat({2,3,4}, 1) -- set to (1,2,3,4)\n\n\n\n\nOr from a \nvector3\n and a number (or a number and a \nvector3\n):\n\n\nlocal foo = luacml.quat(luacml.vector3(2,3,4), 1) -- set to (1,2,3,4)\nlocal bar = luacml.quat(1, luacml.vector3(2,3,4)) -- set to (1,2,3,4)\n\n\n\n\nOr from another quaternion of same type:\n\n\nlocal foo = luacml.quat(1,2,3,4)\nlocal bar = luacml.quat(foo) -- set to (1,2,3,4)\n\n\n\n\nParameters\n\n\n\n\n4 numbers.\n\n\nor 1 table of 4 numbers.\n\n\nor 1 \nvector4\n.\n\n\nor 1 table of 3 numbers and 1 number.\n\n\nor 1 number and a table of 3 numbers.\n\n\nor 1 \nvector3\n and 1 number.\n\n\nor 1 number and 1 \nvector3\n.\n\n\nor 1 quaternion of same type.\n\n\n\n\nReturns\n\n\nThe newly constructed quaternion.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\nset()\n\n\nQuaternions can be set from individual numbers:\n\n\nlocal foo = luacml.quat()\nfoo:set(1,2,3,4) -- set to (1,2,3,4)\n\n\n\n\nOr from a table of numbers:\n\n\nlocal foo = luacml.quat()\nfoo:set({1,2,3,4}) -- set to (1,2,3,4)\n\n\n\n\nOr from a \nvector4\n:\n\n\nlocal foo = luacml.quat_p()\nfoo:set(luacml.vector4(1,2,3,4)) -- set to (1,2,3,4)\n\n\n\n\nOr from a table and a number (or a number and a table):\n\n\nlocal foo = luacml.quat_p()\nfoo:set({2,3,4}, 1) -- set to (2,3,4,1)\nfoo:set(1, {2,3,4}) -- set to (2,3,4,1)\n\n\n\n\nOr from a \nvector3\n and a number (or a number and a \nvector3\n):\n\n\nlocal foo = luacml.quat_n()\nfoo:set(luacml.vector3(1,2,3), 4) -- set to (1,2,3,4)\nfoo:set(4, luacml.vector3(1,2,3)) -- set to (1,2,3,4)\n\n\n\n\nOr from another quaternion of same type:\n\n\nlocal foo = luacml.quat_n()\nfoo:set(luacml.quat_n(1,2,3,4)) -- set to (1,2,3,4)\n\n\n\n\nParameters\n\n\n\n\n4 numbers.\n\n\nor 1 table of 4 numbers.\n\n\nor 1 \nvector4\n.\n\n\nor 1 table of 3 numbers and 1 number.\n\n\nor 1 number and a table of 3 numbers.\n\n\nor 1 \nvector3\n and 1 number.\n\n\nor 1 number and 1 \nvector3\n.\n\n\nor 1 quaternion of same type.\n\n\n\n\nReturns\n\n\nThe quaternion, after it has been set.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\ntotable()\n\n\nQuaternions can be converted to a table:\n\n\nlocal foo = luacml.quat_p(1,2,3,4)\nlocal bar = foo:totable()\nprint(bar[1], bar[2], bar[3], bar[4]) -- prints: 1 2 3 4\n\n\n\n\nParameters\n\n\n(None)\n\n\nReturns\n\n\nAn array containing the quaternion's elements.\n\n\nErrors\n\n\n\n\nExtra arguments.\n\n\n\n\n\n\nlength()\n\n\nThe length of a quaternion can be found:\n\n\nlocal foo = luacml.quat_p(1,2,3,4)\nprint(foo:length()) -- prints: 5.4772255750517\n\n\n\n\nParameters\n\n\n(None)\n\n\nReturns\n\n\nThe quaternion's length as a number.\n\n\nErrors\n\n\n\n\nExtra arguments.\n\n\n\n\n\n\nlength_squared()\n\n\nThe squared-length of a quaternion can be found:\n\n\nlocal foo = luacml.quat_p(1,2,3,4)\nprint(foo:length_squared()) -- prints: 30\n\n\n\n\nParameters\n\n\n(None)\n\n\nReturns\n\n\nThe quaternion's squared length as a number.\n\n\nErrors\n\n\n\n\nExtra arguments.\n\n\n\n\n\n\nnormalize()\n\n\nA quaternion can be normalized in-place:\n\n\nlocal foo = luacml.quat_p(1,1,1,1)\nfoo:normalize() -- set to (0.5,0.5,0.5,0.5)\n\n\n\n\nParameters\n\n\n(None)\n\n\nReturns\n\n\nThe quaternion, after it has been normalized.\n\n\nErrors\n\n\n\n\nExtra arguments.\n\n\n\n\n\n\ninverse()\n\n\nA quaternion can be set to its inverse:\n\n\nlocal foo = luacml.quat_p(1,1,1,1)\nfoo:inverse() -- set to (-0.25,-0.25,-0.25,0.25)\n\n\n\n\nParameters\n\n\n(None)\n\n\nReturns\n\n\nThe quaternion, after it has been inverted.\n\n\nErrors\n\n\n\n\nExtra arguments.\n\n\n\n\n\n\nconjugate()\n\n\nA quaternion can be set to its conjugate:\n\n\nlocal foo = luacml.quat_p(1,1,1,1)\nfoo:conjugate() -- set to (-1,-1,-1,1)\n\n\n\n\nParameters\n\n\n(None)\n\n\nReturns\n\n\nThe quaternion, after it has been set to its conjugate.\n\n\nErrors\n\n\n\n\nExtra arguments.\n\n\n\n\n\n\nidentity()\n\n\nA quaternion can be set to its identity:\n\n\nlocal foo = luacml.quat_p(1,2,3,4)\nfoo:identity() -- set to (0,0,0,1)\n\nlocal bar = luacml.quat(1,2,3,4)\nbar:identity() -- set to (1,0,0,0)\n\n\n\n\nParameters\n\n\n(None)\n\n\nReturns\n\n\nThe quaternion, after it has been set to its identity.\n\n\nErrors\n\n\n\n\nExtra arguments.\n\n\n\n\n\n\nrandom()\n\n\nA quaternion can be set to a random quaternion with elements between specified\nminimum and maximum values.\n\n\nlocal foo = luacml.quat()\nfoo:random(-1,1) -- sets each element to a random value between -1 and 1.\n\n\n\n\nParameters\n\n\n\n\nThe minimum number.\n\n\nThe maximum number.\n\n\n\n\nReturns\n\n\n(None)\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\nimaginary()\n\n\nA quaternion's imaginary/vector part can be retrieved.\n\n\nlocal foo = luacml.quat(1,2,3,4)\nlocal bar = luacml.quat_p(1,2,3,4)\nprint(foo:imaginary()) -- prints: vector3:\n2,3,4\n\nprint(bar:imaginary()) -- prints: vector3:\n1,2,3\n\n\n\n\n\nParameters\n\n\n(None)\n\n\nReturns\n\n\nReturns a \nvector3\n representing the imaginary (\ni,j,k\n) or (\nx,y,z\n)\ncomponents.\n\n\nErrors\n\n\n\n\nExtra arguments.\n\n\n\n\n\n\nreal()\n\n\nA quaternion's real/scalar part can be retrieved.\n\n\nlocal foo = luacml.quat(1,2,3,4)\nlocal bar = luacml.quat_p(1,2,3,4)\nprint(foo:real()) -- prints: 1\nprint(bar:real()) -- prints: 4\n\n\n\n\nParameters\n\n\n(None)\n\n\nReturns\n\n\nReturns a number representing the real (\nw\n) component.\n\n\nErrors\n\n\n\n\nExtra arguments.\n\n\n\n\n\n\nadd()\n\n\nA quaternion can be added with another quaternion of same type.\n\n\nlocal foo = luacml.quat(1,2,3,4)\nlocal bar = luacml.quat(1,2,3,4)\nprint(foo:add(bar)) -- prints: quat:\n2,4,6,8\n\nprint(foo)          -- prints: quat:\n1,2,3,4\n\n\n\n\n\nNote\n\n\nThe original quaternions are unchanged.\n\n\nInternally, this equivalent to the \n__add\n metamethod.\n\n\nParameters\n\n\nA quaternion of same type.\n\n\nReturns\n\n\nA new quaternion representing the element-wise sum.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\nsub()\n\n\nA quaternion can be subtracted from another quaternion.\n\n\nlocal foo = luacml.quat(1,2,3,4)\nlocal bar = luacml.quat(1,2,3,4)\nprint(foo:sub(bar)) -- prints: quat:\n0,0,0,0\n\nprint(foo)          -- prints: quat:\n1,2,3,4\n\n\n\n\n\nNote\n\n\nThe original quaternions are unchanged.\n\n\nInternally, this function is equivalent to the \n__sub\n metamethod.\n\n\nParameters\n\n\nA quaternion of same type.\n\n\nReturns\n\n\nA new quaternion representing the element-wise difference.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\nmul()\n\n\nA quaternion can multiplied with another quaternion or with a number.\n\n\nlocal foo = luacml.quat(1,2,3,4)\nlocal bar = luacml.quat(4,3,2,1)\nprint(foo:mul(bar)) -- prints: quat:\n-12,6,24,12\n\n\n\n\n\nlocal foo = luacml.quat_p(1,2,3,4)\nlocal bar = luacml.quat_p(4,3,2,1)\nprint(foo:mul(bar)) -- prints: quat_p:\n12,24,6,-12\n\n\n\n\n\nlocal foo = luacml.quat_n(1,2,3,4)\nlocal bar = luacml.quat_n(4,3,2,1)\nprint(foo:mul(bar)) -- prints: quat_n:\n22,4,16,-12\n\n\n\n\n\nlocal foo = luacml.quat_p(1,2,3,4)\nprint(foo:mul(2)) -- prints: quat_p:\n2,4,6,8\n\n\n\n\n\nNote\n\n\nThe original quaternion(s) are unchanged.\n\n\nInternally, this function is equivalent to the \n__mul\n metamethod.\n\n\nParameters\n\n\n\n\n1 scalar number.\n\n\nor 1 quaternion of same type.\n\n\n\n\nReturns\n\n\nA new quaternion representing the multiplication result.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\ndiv()\n\n\nA quaternion can be can be divided by a number.\n\n\nlocal foo = luacml.quat_n(2,4,6,8)\nprint(foo:div(2)) -- prints: quat_n:\n1,2,3,4\n\nprint(foo)        -- prints: quat_n:\n2,4,6,8\n\n\n\n\n\nNote\n\n\nThe original quaternion is unchanged.\n\n\nInternally, this function is equivalent to the \n__div\n metamethod.\n\n\nParameters\n\n\n\n\n1 scalar number.\n\n\n\n\nReturns\n\n\nA new quaternion representing the element-wise division.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\naddeq()\n\n\nA quaternion can be incremented in-place with another quaternion.\n\n\nlocal foo = luacml.quat_n(1,2,3,4)\nlocal bar = luacml.quat_n(1,2,3,4)\nprint(foo:addeq(bar)) -- prints: quat_n:\n2,4,6,8\n\nprint(foo)            -- prints: quat_n:\n2,4,6,8\n\n\n\n\n\nNote\n\n\nThe original quaternion (but not the input parameter) is updated.\n\n\nParameters\n\n\n\n\n1 quaternion of same type.\n\n\n\n\nReturns\n\n\nThe updated quaternion after the element-wise sum.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\nsubeq()\n\n\nA quaternion can be subtracted in-place with another quaternion.\n\n\nlocal foo = luacml.quat(1,2,3,4)\nlocal bar = luacml.quat(1,2,3,4)\nprint(foo:subeq(bar)) -- prints: quat:\n0,0,0,0\n\nprint(foo)            -- prints: quat:\n0,0,0,0\n\n\n\n\n\nNote\n\n\nThe original quaternion (but not the parameter) is updated.\n\n\nParameters\n\n\n\n\n1 quaternion of same type.\n\n\n\n\nReturns\n\n\nThe updated quaternion after the element-wise subtraction.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\nmuleq()\n\n\nA quaternion can be multiplied in-place with another quaternion or a number.\n\n\nlocal foo = luacml.quat(1,2,3,4)\nlocal bar = luacml.quat(4,3,2,1)\nprint(foo:muleq(bar)) -- prints: quat:\n-12,6,24,12\n\nprint(foo)            -- prints: quat:\n-12,6,24,12\n\n\n\n\n\nlocal foo = luacml.quat_p(1,2,3,4)\nlocal bar = luacml.quat_p(4,3,2,1)\nprint(foo:muleq(bar)) -- prints: quat_p:\n12,24,6,-12\n\nprint(foo)            -- prints: quat_p:\n12,24,6,-12\n\n\n\n\n\nlocal foo = luacml.quat_n(1,2,3,4)\nlocal bar = luacml.quat_n(4,3,2,1)\nprint(foo:muleq(bar)) -- prints: quat_n:\n22,4,16,-12\n\nprint(foo)            -- prints: quat_n:\n22,4,16,-12\n\n\n\n\n\nlocal foo = luacml.quat_p(1,2,3,4)\nprint(foo:muleq(2)) -- prints: quat_p:\n2,4,6,8\n\nprint(foo)          -- prints: quat_p:\n2,4,6,8\n\n\n\n\n\nNote\n\n\nThe original quaternion (not the parameter) is updated.\n\n\nParameters\n\n\n\n\n1 quaternion of same type.\n\n\nor 1 scalar number.\n\n\n\n\nReturns\n\n\nThe updated quaternion after the multiplication.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\ndiv()\n\n\nA quaternion can be can be divided in-place by a number.\n\n\nlocal foo = luacml.quat_n(2,4,6,8)\nprint(foo:diveq(2)) -- prints: quat_n:\n1,2,3,4\n\nprint(foo)          -- prints: quat_n:\n1,2,3,4\n\n\n\n\n\nNote\n\n\nThe original quaternion is updated.\n\n\nParameters\n\n\n\n\n1 scalar number.\n\n\n\n\nReturns\n\n\nA new quaternion representing the element-wise division.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\nQuaternion metamethods\n\n\nAll vector types have a set of\n\nmetamethods\n that allow them to\nbe used with several operators.\n\n\n\n\n__index\n\n\nThe __index metamethod permits quaternion element access.\n\n\nQuaternions can be indexed with 1-based integer keys:\n\n\nlocal foo = luacml.quat(10,20,30,40)\nlocal bar = luacml.quat_p(10,20,30,40)\nprint(foo[1]) -- prints: 10\nprint(bar[1]) -- prints: 10\n\n\n\n\nOr with case-insensitive \"x\", \"y\", \"z\", or \"w\" string keys:\n\n\nlocal foo = luacml.quat(10,20,30,40)\nlocal bar = luacml.quat_p(10,20,30,40)\nprint(foo.x)    -- prints: 20\nprint(foo.W)    -- prints: 10\nprint(bar[\nw\n]) -- prints: 40\nprint(bar[\nZ\n]) -- prints: 30\n\n\n\n\nParameters\n\n\n\n\nAn integer from 1 to 4.\n\n\nor one of {x, y, z, w}.\n\n\n\n\nReturns\n\n\nThe quaternion's element as a number.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nInvalid index value.\n\n\nInvalid index type.\n\n\n\n\n\n\n__newindex\n\n\nThe __newindex metamethod permits vector element setting.\n\n\nQuaternions can be indexed with 1-based integer keys:\n\n\nlocal foo = luacml.quat(0,0,0,0)\nlocal bar = luacml.quat_p(0,0,0,0)\nfoo[1] = 10 -- Set to (1,0,0,0)\nbar[1] = 10 -- Set to (1,0,0,0)\n\n\n\n\nOr with case-insensitive \"x\", \"y\", \"z\", or \"w\" string keys:\n\n\nlocal foo = luacml.quat(0,0,0,0)\nfoo.x = 10\nfoo.Y = 20\nfoo[\nz\n] = 30\n-- Set to (0,10,20,30)\n\n\n\n\nParameters\n\n\n\n\nAn integer from 1 to 4.\n\n\nor one of {x, y, z, w}.\n\n\n\n\nReturns\n\n\n(None)\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nInvalid index value.\n\n\nInvalid index type.\n\n\n\n\n\n\n__tostring\n\n\nQuaternions can be converted to strings for easy printing.\n\n\nlocal foo = luacml.quat(1,2,3,4)\nlocal bar = luacml.quat_p(1,2,3,4)\nlocal baz = luacml.quat_n(1,2,3,4)\nprint(foo) -- prints: quat:\n1,2,3,4\n\nprint(bar) -- prints: quat_p:\n1,2,3,4\n\nprint(baz) -- prints: quat_n:\n1,2,3,4\n\n\n\n\n\nNote\n\n\nThis function internally uses \nlua_pushfstring\n to format the output, so be\naware of different formatting across versions of Lua.\n\n\nParameters\n\n\n\n\n1 quaternion.\n\n\n\n\nReturns\n\n\nThe quaternion formatted as a string.\n\n\nErrors\n\n\n(None)\n\n\n\n\n__unm\n\n\nThe negative of a quaternion can be generated.\n\n\nlocal foo = luacml.quat(1,2,-3,-4)\nprint(-foo) -- prints: quat:\n-1,-2,3,4\n\n\n\n\n\nNote\n\n\nThe original quaternion is unchanged.\n\n\nParameters\n\n\n\n\n1 quaternion.\n\n\n\n\nReturns\n\n\nA new quaternion representing the negative of the original.\n\n\nErrors\n\n\n(None)\n\n\n\n\n__add\n\n\nTwo quaternions can be added together.\n\n\nlocal foo = luacml.quat(1,2,3,4)\nlocal bar = luacml.quat(4,3,2,1)\nprint(foo + bar) -- prints: quat\n5,5,5,5\n\n\n\n\n\nNote\n\n\nThe original quaternions are unchanged.\n\n\nParameters\n\n\n\n\n2 quaternions of same type.\n\n\n\n\nReturns\n\n\nA new quaternion representing the element-wise sum.\n\n\nErrors\n\n\n\n\nInvalid types.\n\n\n\n\n\n\n__sub\n\n\nTwo quaternions can be subtracted.\n\n\nlocal foo = luacml.quat(1,2,3,4)\nlocal bar = luacml.quat(4,3,2,1)\nprint(foo - bar) -- prints: quat\n-3,-1,1,3\n\n\n\n\n\nNote\n\n\nThe original quaternions are unchanged.\n\n\nParameters\n\n\n\n\n2 quaternions of same type.\n\n\n\n\nReturns\n\n\nA new quaternion representing the element-wise difference.\n\n\nErrors\n\n\n\n\nInvalid types.\n\n\n\n\n\n\n__mul\n\n\nQuaternions can be scaled.\n\n\nlocal foo = luacml.quat_p(1,2,3,4)\nprint(2.0 * foo) -- prints: quat_p\n2,4,6,8\n\nprint(foo * 3.0) -- prints: quat_p\n3,6,9,12\n\n\n\n\n\nNote\n\n\nThe original quaternion is unchanged.\n\n\nParameters\n\n\n\n\n1 quaternion and 1 number.\n\n\nor 1 number and 1 quaternion.\n\n\n\n\nReturns\n\n\nA new quaternion representing the element-wise scale.\n\n\nErrors\n\n\n\n\nInvalid types.\n\n\n\n\n\n\n__div\n\n\nQuaternions can be inverse divided.\n\n\nlocal foo = luacml.quat_p(2,4,6,8)\nprint(foo / 2.0) -- prints: quat_p\n1,2,3,4\n\n\n\n\n\nNote\n\n\nThe original quaternion is unchanged.\n\n\nParameters\n\n\n\n\n1 quaternion and 1 number.\n\n\n\n\nReturns\n\n\nA new quaternion representing the element-wise division.\n\n\nErrors\n\n\n\n\nInvalid types.\n\n\n\n\n\n\n__eq\n\n\nQuaternions can be compared.\n\n\nlocal foo = luacml.quat_p(2,4,6)\nlocal bar = luacml.quat_p(2,4,6)\nlocal baz = luacml.quat_p(1,2,3)\nprint(foo == bar) -- prints: true\nprint(foo ~= baz) -- prints: false\n\n\n\n\nNote\n\n\nThe original quaternions are unchanged.\n\n\nParameters\n\n\n\n\n2 quaternions of same type.\n\n\n\n\nReturns\n\n\nBoolean representing element-wise equality.\n\n\nErrors\n\n\n\n\nInvalid types.", 
            "title": "Quaternion docs"
        }, 
        {
            "location": "/quaternion-docs/#quaternions", 
            "text": "", 
            "title": "Quaternions"
        }, 
        {
            "location": "/quaternion-docs/#quaternion-types", 
            "text": "The following quaternion types are provided by LuaCML:     Type  Description      quat  A scalar-first, positive cross quaternion based on  lua_Number    quat_p  A vector-first, positive cross quaternion based on  lua_Number    quat_n  A vector-first, negative cross quaternion based on  lua_Number", 
            "title": "Quaternion types"
        }, 
        {
            "location": "/quaternion-docs/#note", 
            "text": "The  quat  type is a scalar-first quaternion, ie: (w,x,y,z).  The  quat_p  and  quat_n  types are vector-first quaternions, ie: (x,y,z,w).  The  quat_p  (or positive cross) type determines the multiplication order of two\nquaternions in \"standard\" form. A multiplication of  q1*q2  represents the\nrotation of  q2  applied first, followed by  q1 .  The  quat_n  (or negative cross) type determines the multiplication order of two\nquaternions in \"reverse\" form. A multiplication of  q1*q2  represents the\nrotation of  q1  applied first, followed by  q2 .", 
            "title": "Note:"
        }, 
        {
            "location": "/quaternion-docs/#quaternion-functions", 
            "text": "", 
            "title": "Quaternion functions"
        }, 
        {
            "location": "/quaternion-docs/#constructor", 
            "text": "Quaternions have default constructors initialized with identity:  local foo = luacml.quat()   -- set to (1,0,0,0)\nlocal bar = luacml.quat_p() -- set to (0,0,0,1)\nlocal baz = luacml.quat_n() -- set to (0,0,0,1)  Quaternions can be constructed from individual numbers:  local foo = luacml.quat(1,2,3,4)   -- set to (1,2,3,4)\nlocal bar = luacml.quat_p(1,2,3,4) -- set to (1,2,3,4)\nlocal baz = luacml.quat_n(1,2,3,4) -- set to (1,2,3,4)  Or from a table of numbers:  local foo = luacml.quat({1,2,3,4})   -- set to (1,2,3,4)\nlocal bar = luacml.quat_p({1,2,3,4}) -- set to (1,2,3,4)\nlocal baz = luacml.quat_n({1,2,3,4}) -- set to (1,2,3,4)  Or from a  vector4 :  local foo = luacml.quat(luacml.vector4(1,2,3,4))   -- set to (1,2,3,4)\nlocal bar = luacml.quat_p(luacml.vector4(1,2,3,4)) -- set to (1,2,3,4)\nlocal baz = luacml.quat_n(luacml.vector4(1,2,3,4)) -- set to (1,2,3,4)  Or from a table and a number (or a number and a table):  local foo = luacml.quat(1, {2,3,4}) -- set to (1,2,3,4)\nlocal bar = luacml.quat({2,3,4}, 1) -- set to (1,2,3,4)  Or from a  vector3  and a number (or a number and a  vector3 ):  local foo = luacml.quat(luacml.vector3(2,3,4), 1) -- set to (1,2,3,4)\nlocal bar = luacml.quat(1, luacml.vector3(2,3,4)) -- set to (1,2,3,4)  Or from another quaternion of same type:  local foo = luacml.quat(1,2,3,4)\nlocal bar = luacml.quat(foo) -- set to (1,2,3,4)", 
            "title": "constructor"
        }, 
        {
            "location": "/quaternion-docs/#parameters", 
            "text": "4 numbers.  or 1 table of 4 numbers.  or 1  vector4 .  or 1 table of 3 numbers and 1 number.  or 1 number and a table of 3 numbers.  or 1  vector3  and 1 number.  or 1 number and 1  vector3 .  or 1 quaternion of same type.", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns", 
            "text": "The newly constructed quaternion.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#set", 
            "text": "Quaternions can be set from individual numbers:  local foo = luacml.quat()\nfoo:set(1,2,3,4) -- set to (1,2,3,4)  Or from a table of numbers:  local foo = luacml.quat()\nfoo:set({1,2,3,4}) -- set to (1,2,3,4)  Or from a  vector4 :  local foo = luacml.quat_p()\nfoo:set(luacml.vector4(1,2,3,4)) -- set to (1,2,3,4)  Or from a table and a number (or a number and a table):  local foo = luacml.quat_p()\nfoo:set({2,3,4}, 1) -- set to (2,3,4,1)\nfoo:set(1, {2,3,4}) -- set to (2,3,4,1)  Or from a  vector3  and a number (or a number and a  vector3 ):  local foo = luacml.quat_n()\nfoo:set(luacml.vector3(1,2,3), 4) -- set to (1,2,3,4)\nfoo:set(4, luacml.vector3(1,2,3)) -- set to (1,2,3,4)  Or from another quaternion of same type:  local foo = luacml.quat_n()\nfoo:set(luacml.quat_n(1,2,3,4)) -- set to (1,2,3,4)", 
            "title": "set()"
        }, 
        {
            "location": "/quaternion-docs/#parameters_1", 
            "text": "4 numbers.  or 1 table of 4 numbers.  or 1  vector4 .  or 1 table of 3 numbers and 1 number.  or 1 number and a table of 3 numbers.  or 1  vector3  and 1 number.  or 1 number and 1  vector3 .  or 1 quaternion of same type.", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_1", 
            "text": "The quaternion, after it has been set.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_1", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#totable", 
            "text": "Quaternions can be converted to a table:  local foo = luacml.quat_p(1,2,3,4)\nlocal bar = foo:totable()\nprint(bar[1], bar[2], bar[3], bar[4]) -- prints: 1 2 3 4", 
            "title": "totable()"
        }, 
        {
            "location": "/quaternion-docs/#parameters_2", 
            "text": "(None)", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_2", 
            "text": "An array containing the quaternion's elements.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_2", 
            "text": "Extra arguments.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#length", 
            "text": "The length of a quaternion can be found:  local foo = luacml.quat_p(1,2,3,4)\nprint(foo:length()) -- prints: 5.4772255750517", 
            "title": "length()"
        }, 
        {
            "location": "/quaternion-docs/#parameters_3", 
            "text": "(None)", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_3", 
            "text": "The quaternion's length as a number.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_3", 
            "text": "Extra arguments.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#length_squared", 
            "text": "The squared-length of a quaternion can be found:  local foo = luacml.quat_p(1,2,3,4)\nprint(foo:length_squared()) -- prints: 30", 
            "title": "length_squared()"
        }, 
        {
            "location": "/quaternion-docs/#parameters_4", 
            "text": "(None)", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_4", 
            "text": "The quaternion's squared length as a number.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_4", 
            "text": "Extra arguments.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#normalize", 
            "text": "A quaternion can be normalized in-place:  local foo = luacml.quat_p(1,1,1,1)\nfoo:normalize() -- set to (0.5,0.5,0.5,0.5)", 
            "title": "normalize()"
        }, 
        {
            "location": "/quaternion-docs/#parameters_5", 
            "text": "(None)", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_5", 
            "text": "The quaternion, after it has been normalized.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_5", 
            "text": "Extra arguments.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#inverse", 
            "text": "A quaternion can be set to its inverse:  local foo = luacml.quat_p(1,1,1,1)\nfoo:inverse() -- set to (-0.25,-0.25,-0.25,0.25)", 
            "title": "inverse()"
        }, 
        {
            "location": "/quaternion-docs/#parameters_6", 
            "text": "(None)", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_6", 
            "text": "The quaternion, after it has been inverted.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_6", 
            "text": "Extra arguments.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#conjugate", 
            "text": "A quaternion can be set to its conjugate:  local foo = luacml.quat_p(1,1,1,1)\nfoo:conjugate() -- set to (-1,-1,-1,1)", 
            "title": "conjugate()"
        }, 
        {
            "location": "/quaternion-docs/#parameters_7", 
            "text": "(None)", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_7", 
            "text": "The quaternion, after it has been set to its conjugate.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_7", 
            "text": "Extra arguments.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#identity", 
            "text": "A quaternion can be set to its identity:  local foo = luacml.quat_p(1,2,3,4)\nfoo:identity() -- set to (0,0,0,1)\n\nlocal bar = luacml.quat(1,2,3,4)\nbar:identity() -- set to (1,0,0,0)", 
            "title": "identity()"
        }, 
        {
            "location": "/quaternion-docs/#parameters_8", 
            "text": "(None)", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_8", 
            "text": "The quaternion, after it has been set to its identity.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_8", 
            "text": "Extra arguments.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#random", 
            "text": "A quaternion can be set to a random quaternion with elements between specified\nminimum and maximum values.  local foo = luacml.quat()\nfoo:random(-1,1) -- sets each element to a random value between -1 and 1.", 
            "title": "random()"
        }, 
        {
            "location": "/quaternion-docs/#parameters_9", 
            "text": "The minimum number.  The maximum number.", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_9", 
            "text": "(None)", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_9", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#imaginary", 
            "text": "A quaternion's imaginary/vector part can be retrieved.  local foo = luacml.quat(1,2,3,4)\nlocal bar = luacml.quat_p(1,2,3,4)\nprint(foo:imaginary()) -- prints: vector3: 2,3,4 \nprint(bar:imaginary()) -- prints: vector3: 1,2,3", 
            "title": "imaginary()"
        }, 
        {
            "location": "/quaternion-docs/#parameters_10", 
            "text": "(None)", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_10", 
            "text": "Returns a  vector3  representing the imaginary ( i,j,k ) or ( x,y,z )\ncomponents.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_10", 
            "text": "Extra arguments.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#real", 
            "text": "A quaternion's real/scalar part can be retrieved.  local foo = luacml.quat(1,2,3,4)\nlocal bar = luacml.quat_p(1,2,3,4)\nprint(foo:real()) -- prints: 1\nprint(bar:real()) -- prints: 4", 
            "title": "real()"
        }, 
        {
            "location": "/quaternion-docs/#parameters_11", 
            "text": "(None)", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_11", 
            "text": "Returns a number representing the real ( w ) component.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_11", 
            "text": "Extra arguments.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#add", 
            "text": "A quaternion can be added with another quaternion of same type.  local foo = luacml.quat(1,2,3,4)\nlocal bar = luacml.quat(1,2,3,4)\nprint(foo:add(bar)) -- prints: quat: 2,4,6,8 \nprint(foo)          -- prints: quat: 1,2,3,4", 
            "title": "add()"
        }, 
        {
            "location": "/quaternion-docs/#note_1", 
            "text": "The original quaternions are unchanged.  Internally, this equivalent to the  __add  metamethod.", 
            "title": "Note"
        }, 
        {
            "location": "/quaternion-docs/#parameters_12", 
            "text": "A quaternion of same type.", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_12", 
            "text": "A new quaternion representing the element-wise sum.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_12", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#sub", 
            "text": "A quaternion can be subtracted from another quaternion.  local foo = luacml.quat(1,2,3,4)\nlocal bar = luacml.quat(1,2,3,4)\nprint(foo:sub(bar)) -- prints: quat: 0,0,0,0 \nprint(foo)          -- prints: quat: 1,2,3,4", 
            "title": "sub()"
        }, 
        {
            "location": "/quaternion-docs/#note_2", 
            "text": "The original quaternions are unchanged.  Internally, this function is equivalent to the  __sub  metamethod.", 
            "title": "Note"
        }, 
        {
            "location": "/quaternion-docs/#parameters_13", 
            "text": "A quaternion of same type.", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_13", 
            "text": "A new quaternion representing the element-wise difference.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_13", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#mul", 
            "text": "A quaternion can multiplied with another quaternion or with a number.  local foo = luacml.quat(1,2,3,4)\nlocal bar = luacml.quat(4,3,2,1)\nprint(foo:mul(bar)) -- prints: quat: -12,6,24,12   local foo = luacml.quat_p(1,2,3,4)\nlocal bar = luacml.quat_p(4,3,2,1)\nprint(foo:mul(bar)) -- prints: quat_p: 12,24,6,-12   local foo = luacml.quat_n(1,2,3,4)\nlocal bar = luacml.quat_n(4,3,2,1)\nprint(foo:mul(bar)) -- prints: quat_n: 22,4,16,-12   local foo = luacml.quat_p(1,2,3,4)\nprint(foo:mul(2)) -- prints: quat_p: 2,4,6,8", 
            "title": "mul()"
        }, 
        {
            "location": "/quaternion-docs/#note_3", 
            "text": "The original quaternion(s) are unchanged.  Internally, this function is equivalent to the  __mul  metamethod.", 
            "title": "Note"
        }, 
        {
            "location": "/quaternion-docs/#parameters_14", 
            "text": "1 scalar number.  or 1 quaternion of same type.", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_14", 
            "text": "A new quaternion representing the multiplication result.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_14", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#div", 
            "text": "A quaternion can be can be divided by a number.  local foo = luacml.quat_n(2,4,6,8)\nprint(foo:div(2)) -- prints: quat_n: 1,2,3,4 \nprint(foo)        -- prints: quat_n: 2,4,6,8", 
            "title": "div()"
        }, 
        {
            "location": "/quaternion-docs/#note_4", 
            "text": "The original quaternion is unchanged.  Internally, this function is equivalent to the  __div  metamethod.", 
            "title": "Note"
        }, 
        {
            "location": "/quaternion-docs/#parameters_15", 
            "text": "1 scalar number.", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_15", 
            "text": "A new quaternion representing the element-wise division.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_15", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#addeq", 
            "text": "A quaternion can be incremented in-place with another quaternion.  local foo = luacml.quat_n(1,2,3,4)\nlocal bar = luacml.quat_n(1,2,3,4)\nprint(foo:addeq(bar)) -- prints: quat_n: 2,4,6,8 \nprint(foo)            -- prints: quat_n: 2,4,6,8", 
            "title": "addeq()"
        }, 
        {
            "location": "/quaternion-docs/#note_5", 
            "text": "The original quaternion (but not the input parameter) is updated.", 
            "title": "Note"
        }, 
        {
            "location": "/quaternion-docs/#parameters_16", 
            "text": "1 quaternion of same type.", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_16", 
            "text": "The updated quaternion after the element-wise sum.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_16", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#subeq", 
            "text": "A quaternion can be subtracted in-place with another quaternion.  local foo = luacml.quat(1,2,3,4)\nlocal bar = luacml.quat(1,2,3,4)\nprint(foo:subeq(bar)) -- prints: quat: 0,0,0,0 \nprint(foo)            -- prints: quat: 0,0,0,0", 
            "title": "subeq()"
        }, 
        {
            "location": "/quaternion-docs/#note_6", 
            "text": "The original quaternion (but not the parameter) is updated.", 
            "title": "Note"
        }, 
        {
            "location": "/quaternion-docs/#parameters_17", 
            "text": "1 quaternion of same type.", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_17", 
            "text": "The updated quaternion after the element-wise subtraction.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_17", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#muleq", 
            "text": "A quaternion can be multiplied in-place with another quaternion or a number.  local foo = luacml.quat(1,2,3,4)\nlocal bar = luacml.quat(4,3,2,1)\nprint(foo:muleq(bar)) -- prints: quat: -12,6,24,12 \nprint(foo)            -- prints: quat: -12,6,24,12   local foo = luacml.quat_p(1,2,3,4)\nlocal bar = luacml.quat_p(4,3,2,1)\nprint(foo:muleq(bar)) -- prints: quat_p: 12,24,6,-12 \nprint(foo)            -- prints: quat_p: 12,24,6,-12   local foo = luacml.quat_n(1,2,3,4)\nlocal bar = luacml.quat_n(4,3,2,1)\nprint(foo:muleq(bar)) -- prints: quat_n: 22,4,16,-12 \nprint(foo)            -- prints: quat_n: 22,4,16,-12   local foo = luacml.quat_p(1,2,3,4)\nprint(foo:muleq(2)) -- prints: quat_p: 2,4,6,8 \nprint(foo)          -- prints: quat_p: 2,4,6,8", 
            "title": "muleq()"
        }, 
        {
            "location": "/quaternion-docs/#note_7", 
            "text": "The original quaternion (not the parameter) is updated.", 
            "title": "Note"
        }, 
        {
            "location": "/quaternion-docs/#parameters_18", 
            "text": "1 quaternion of same type.  or 1 scalar number.", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_18", 
            "text": "The updated quaternion after the multiplication.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_18", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#div_1", 
            "text": "A quaternion can be can be divided in-place by a number.  local foo = luacml.quat_n(2,4,6,8)\nprint(foo:diveq(2)) -- prints: quat_n: 1,2,3,4 \nprint(foo)          -- prints: quat_n: 1,2,3,4", 
            "title": "div()"
        }, 
        {
            "location": "/quaternion-docs/#note_8", 
            "text": "The original quaternion is updated.", 
            "title": "Note"
        }, 
        {
            "location": "/quaternion-docs/#parameters_19", 
            "text": "1 scalar number.", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_19", 
            "text": "A new quaternion representing the element-wise division.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_19", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#quaternion-metamethods", 
            "text": "All vector types have a set of metamethods  that allow them to\nbe used with several operators.", 
            "title": "Quaternion metamethods"
        }, 
        {
            "location": "/quaternion-docs/#__index", 
            "text": "The __index metamethod permits quaternion element access.  Quaternions can be indexed with 1-based integer keys:  local foo = luacml.quat(10,20,30,40)\nlocal bar = luacml.quat_p(10,20,30,40)\nprint(foo[1]) -- prints: 10\nprint(bar[1]) -- prints: 10  Or with case-insensitive \"x\", \"y\", \"z\", or \"w\" string keys:  local foo = luacml.quat(10,20,30,40)\nlocal bar = luacml.quat_p(10,20,30,40)\nprint(foo.x)    -- prints: 20\nprint(foo.W)    -- prints: 10\nprint(bar[ w ]) -- prints: 40\nprint(bar[ Z ]) -- prints: 30", 
            "title": "__index"
        }, 
        {
            "location": "/quaternion-docs/#parameters_20", 
            "text": "An integer from 1 to 4.  or one of {x, y, z, w}.", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_20", 
            "text": "The quaternion's element as a number.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_20", 
            "text": "Missing arguments.  Invalid index value.  Invalid index type.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#__newindex", 
            "text": "The __newindex metamethod permits vector element setting.  Quaternions can be indexed with 1-based integer keys:  local foo = luacml.quat(0,0,0,0)\nlocal bar = luacml.quat_p(0,0,0,0)\nfoo[1] = 10 -- Set to (1,0,0,0)\nbar[1] = 10 -- Set to (1,0,0,0)  Or with case-insensitive \"x\", \"y\", \"z\", or \"w\" string keys:  local foo = luacml.quat(0,0,0,0)\nfoo.x = 10\nfoo.Y = 20\nfoo[ z ] = 30\n-- Set to (0,10,20,30)", 
            "title": "__newindex"
        }, 
        {
            "location": "/quaternion-docs/#parameters_21", 
            "text": "An integer from 1 to 4.  or one of {x, y, z, w}.", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_21", 
            "text": "(None)", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_21", 
            "text": "Missing arguments.  Invalid index value.  Invalid index type.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#__tostring", 
            "text": "Quaternions can be converted to strings for easy printing.  local foo = luacml.quat(1,2,3,4)\nlocal bar = luacml.quat_p(1,2,3,4)\nlocal baz = luacml.quat_n(1,2,3,4)\nprint(foo) -- prints: quat: 1,2,3,4 \nprint(bar) -- prints: quat_p: 1,2,3,4 \nprint(baz) -- prints: quat_n: 1,2,3,4", 
            "title": "__tostring"
        }, 
        {
            "location": "/quaternion-docs/#note_9", 
            "text": "This function internally uses  lua_pushfstring  to format the output, so be\naware of different formatting across versions of Lua.", 
            "title": "Note"
        }, 
        {
            "location": "/quaternion-docs/#parameters_22", 
            "text": "1 quaternion.", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_22", 
            "text": "The quaternion formatted as a string.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_22", 
            "text": "(None)", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#__unm", 
            "text": "The negative of a quaternion can be generated.  local foo = luacml.quat(1,2,-3,-4)\nprint(-foo) -- prints: quat: -1,-2,3,4", 
            "title": "__unm"
        }, 
        {
            "location": "/quaternion-docs/#note_10", 
            "text": "The original quaternion is unchanged.", 
            "title": "Note"
        }, 
        {
            "location": "/quaternion-docs/#parameters_23", 
            "text": "1 quaternion.", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_23", 
            "text": "A new quaternion representing the negative of the original.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_23", 
            "text": "(None)", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#__add", 
            "text": "Two quaternions can be added together.  local foo = luacml.quat(1,2,3,4)\nlocal bar = luacml.quat(4,3,2,1)\nprint(foo + bar) -- prints: quat 5,5,5,5", 
            "title": "__add"
        }, 
        {
            "location": "/quaternion-docs/#note_11", 
            "text": "The original quaternions are unchanged.", 
            "title": "Note"
        }, 
        {
            "location": "/quaternion-docs/#parameters_24", 
            "text": "2 quaternions of same type.", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_24", 
            "text": "A new quaternion representing the element-wise sum.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_24", 
            "text": "Invalid types.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#__sub", 
            "text": "Two quaternions can be subtracted.  local foo = luacml.quat(1,2,3,4)\nlocal bar = luacml.quat(4,3,2,1)\nprint(foo - bar) -- prints: quat -3,-1,1,3", 
            "title": "__sub"
        }, 
        {
            "location": "/quaternion-docs/#note_12", 
            "text": "The original quaternions are unchanged.", 
            "title": "Note"
        }, 
        {
            "location": "/quaternion-docs/#parameters_25", 
            "text": "2 quaternions of same type.", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_25", 
            "text": "A new quaternion representing the element-wise difference.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_25", 
            "text": "Invalid types.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#__mul", 
            "text": "Quaternions can be scaled.  local foo = luacml.quat_p(1,2,3,4)\nprint(2.0 * foo) -- prints: quat_p 2,4,6,8 \nprint(foo * 3.0) -- prints: quat_p 3,6,9,12", 
            "title": "__mul"
        }, 
        {
            "location": "/quaternion-docs/#note_13", 
            "text": "The original quaternion is unchanged.", 
            "title": "Note"
        }, 
        {
            "location": "/quaternion-docs/#parameters_26", 
            "text": "1 quaternion and 1 number.  or 1 number and 1 quaternion.", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_26", 
            "text": "A new quaternion representing the element-wise scale.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_26", 
            "text": "Invalid types.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#__div", 
            "text": "Quaternions can be inverse divided.  local foo = luacml.quat_p(2,4,6,8)\nprint(foo / 2.0) -- prints: quat_p 1,2,3,4", 
            "title": "__div"
        }, 
        {
            "location": "/quaternion-docs/#note_14", 
            "text": "The original quaternion is unchanged.", 
            "title": "Note"
        }, 
        {
            "location": "/quaternion-docs/#parameters_27", 
            "text": "1 quaternion and 1 number.", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_27", 
            "text": "A new quaternion representing the element-wise division.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_27", 
            "text": "Invalid types.", 
            "title": "Errors"
        }, 
        {
            "location": "/quaternion-docs/#__eq", 
            "text": "Quaternions can be compared.  local foo = luacml.quat_p(2,4,6)\nlocal bar = luacml.quat_p(2,4,6)\nlocal baz = luacml.quat_p(1,2,3)\nprint(foo == bar) -- prints: true\nprint(foo ~= baz) -- prints: false", 
            "title": "__eq"
        }, 
        {
            "location": "/quaternion-docs/#note_15", 
            "text": "The original quaternions are unchanged.", 
            "title": "Note"
        }, 
        {
            "location": "/quaternion-docs/#parameters_28", 
            "text": "2 quaternions of same type.", 
            "title": "Parameters"
        }, 
        {
            "location": "/quaternion-docs/#returns_28", 
            "text": "Boolean representing element-wise equality.", 
            "title": "Returns"
        }, 
        {
            "location": "/quaternion-docs/#errors_28", 
            "text": "Invalid types.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/", 
            "text": "Vectors\n\n\nVector types\n\n\nThe following vector types are provided by LuaCML:\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvector2\n\n\nA two-element vector based on \nlua_Number\n\n\n\n\n\n\nvector3\n\n\nA three-element vector based on \nlua_Number\n\n\n\n\n\n\nvector4\n\n\nA four-element vector based on \nlua_Number\n\n\n\n\n\n\n\n\nVector functions\n\n\nconstructor\n\n\nVectors have default constructors initialized with zeros:\n\n\nlocal foo = luacml.vector3() -- set to (0,0,0)\n\n\n\n\nVectors can be constructed from individual numbers:\n\n\nlocal foo = luacml.vector4(1,2,3,4)\n\n\n\n\nOr from a table of numbers:\n\n\nlocal foo = luacml.vector2({1,2})\n\n\n\n\nOr from another vector:\n\n\nlocal foo = luacml.vector3(1,2,3)\nlocal bar = luacml.vector3(foo) -- set to (1,2,3)\n\n\n\n\nParameters\n\n\n\n\nN\n numbers.\n\n\nor table of \nN\n numbers.\n\n\nor a vector of size \nN\n.\n\n\n\n\nReturns\n\n\nThe newly constructed vector.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\nset()\n\n\nVectors can be set from individual numbers:\n\n\nlocal foo = luacml.vector3()\nfoo:set(1,2,3)\n\n\n\n\nOr from a table of numbers:\n\n\nlocal foo = luacml.vector3()\nfoo:set({1,2,3})\n\n\n\n\nOr from another vector:\n\n\nlocal foo = luacml.vector3()\nfoo:set(luacml.vector3(1,2,3))\n\n\n\n\nParameters\n\n\n\n\nN\n numbers.\n\n\nor table of \nN\n numbers.\n\n\nor a vector of size \nN\n.\n\n\n\n\nReturns\n\n\nThe vector, after it has been set.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\ntotable()\n\n\nVectors can be converted to a table:\n\n\nlocal foo = luacml.vector3(1,2,3)\nlocal bar = foo:totable()\nprint(bar[1], bar[2], bar[3]) -- prints: 1 2 3\n\n\n\n\nParameters\n\n\n(None)\n\n\nReturns\n\n\nAn array containing the vector's elements.\n\n\nErrors\n\n\n\n\nExtra arguments.\n\n\n\n\n\n\nlength()\n\n\nThe length of a vector can be found:\n\n\nlocal foo = luacml.vector3(1,2,3)\nprint(foo:length())\n\n\n\n\nParameters\n\n\n(None)\n\n\nReturns\n\n\nThe vector's length as a number.\n\n\nErrors\n\n\n\n\nExtra arguments.\n\n\n\n\n\n\nlength_squared()\n\n\nThe squared-length of a vector can be found:\n\n\nlocal foo = luacml.vector3(1,2,3)\nprint(foo:length_squared())\n\n\n\n\nParameters\n\n\n(None)\n\n\nReturns\n\n\nThe vector's squared length as a number.\n\n\nErrors\n\n\n\n\nExtra arguments.\n\n\n\n\n\n\nnormalize()\n\n\nA vector can be normalized in-place:\n\n\nlocal foo = luacml.vector3(1,2,3)\nfoo:normalize()\n\n\n\n\nParameters\n\n\n(None)\n\n\nReturns\n\n\nThe vector, after it has been normalized.\n\n\nErrors\n\n\n\n\nExtra arguments.\n\n\n\n\n\n\nzero()\n\n\nA vector can be zeroed in-place:\n\n\nlocal foo = luacml.vector3(1,2,3)\nfoo:zero()\n\n\n\n\nParameters\n\n\n(None)\n\n\nReturns\n\n\nThe vector, after it has been zeroed.\n\n\nErrors\n\n\n\n\nExtra arguments.\n\n\n\n\n\n\ncardinal()\n\n\nA vector can be set to a cardinal axis:\n\n\nlocal foo = luacml.vector3(1,2,3)\nfoo:cardinal(1) -- sets to \n1,0,0\n\nfoo:cardinal(2) -- sets to \n0,1,0\n\nfoo:cardinal(3) -- sets to \n0,0,1\n\n\n\n\n\nParameters\n\n\nAn integer from 1 to \nN\n for a vector of size \nN\n.\n\n\nReturns\n\n\nThe vector, after it has been set.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\nminimize()\n\n\nA vector can be set to the element-wise minimum of itself and another vector.\n\n\nlocal foo = luacml.vector3(10,20,30)\nlocal bar = luacml.vector3(1,200,29)\nfoo:minimize(bar) -- sets to \n1,20,29\n\n\n\n\n\nParameters\n\n\nA vector of same size.\n\n\nReturns\n\n\n(None)\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\nmaximize()\n\n\nA vector can be set to the element-wise maximum of itself and another vector.\n\n\nlocal foo = luacml.vector3(10,20,30)\nlocal bar = luacml.vector3(1,200,29)\nfoo:maximize(bar) -- sets to \n10,200,30\n\n\n\n\n\nParameters\n\n\nA vector of same size.\n\n\nReturns\n\n\n(None)\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\nrandom()\n\n\nA vector can be set to a random vector with elements between specified minimum\nand maximum values.\n\n\nlocal foo = luacml.vector3()\nfoo:random(-1,1) -- sets each element to a random value between -1 and 1.\n\n\n\n\nParameters\n\n\n\n\nThe minimum number.\n\n\nThe maximum number.\n\n\n\n\nReturns\n\n\n(None)\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\nadd()\n\n\nA vector can be added with another vector.\n\n\nlocal foo = luacml.vector3(1,2,3)\nlocal bar = luacml.vector3(1,2,3)\nprint(foo:add(bar)) -- prints: vector3:\n2,4,6\n\nprint(foo)          -- prints: vector3:\n1,2,3\n\n\n\n\n\nNote\n\n\nThe original vectors are unchanged.\n\n\nInternally, this equivalent to the \n__add\n metamethod.\n\n\nParameters\n\n\nA vector of same type.\n\n\nReturns\n\n\nA new vector representing the element-wise sum.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\nsub()\n\n\nA vector can be added with another vector.\n\n\nlocal foo = luacml.vector3(1,2,3)\nlocal bar = luacml.vector3(1,2,3)\nprint(foo:sub(bar)) -- prints: vector3:\n0,0,0\n\nprint(foo)          -- prints: vector3:\n1,2,3\n\n\n\n\n\nNote\n\n\nThe original vectors are unchanged.\n\n\nInternally, this function is equivalent to the \n__sub\n metamethod.\n\n\nParameters\n\n\nA vector of same type.\n\n\nReturns\n\n\nA new vector representing the element-wise difference.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\nmul()\n\n\nA vector can be scaled with a number.\n\n\nlocal foo = luacml.vector3(1,2,3)\nprint(foo:mul(2)) -- prints: vector3:\n2,4,6\n\nprint(foo)        -- prints: vector3:\n1,2,3\n\n\n\n\n\nNote\n\n\nThe original vector is unchanged.\n\n\nInternally, this function is equivalent to the \n__mul\n metamethod.\n\n\nParameters\n\n\nA scalar number.\n\n\nReturns\n\n\nA new vector representing the element-wise scale.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\ndiv()\n\n\nA vector can be inverse-scaled with a number.\n\n\nlocal foo = luacml.vector3(2,4,6)\nprint(foo:div(2)) -- prints: vector3:\n1,2,3\n\nprint(foo)        -- prints: vector3:\n2,4,6\n\n\n\n\n\nNote\n\n\nThe original vector is unchanged.\n\n\nInternally, this function is equivalent to the \n__div\n metamethod.\n\n\nParameters\n\n\nA scalar number.\n\n\nReturns\n\n\nA new vector representing the element-wise division.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\naddeq()\n\n\nA vector can be incremented in-place with another vector.\n\n\nlocal foo = luacml.vector3(1,2,3)\nlocal bar = luacml.vector3(1,2,3)\nprint(foo:addeq(bar)) -- prints: vector3:\n2,4,6\n\nprint(foo)            -- prints: vector3:\n2,4,6\n\n\n\n\n\nNote\n\n\nThe original vector (not the parameter) is updated.\n\n\nParameters\n\n\nA vector of same type.\n\n\nReturns\n\n\nThe updated vector after the element-wise sum.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\nsubeq()\n\n\nA vector can be subtracted in-place with another vector.\n\n\nlocal foo = luacml.vector3(1,2,3)\nlocal bar = luacml.vector3(1,2,3)\nprint(foo:subeq(bar)) -- prints: vector3:\n0,0,0\n\nprint(foo)            -- prints: vector3:\n0,0,0\n\n\n\n\n\nNote\n\n\nThe original vector (not the parameter) is updated.\n\n\nParameters\n\n\nA vector of same type.\n\n\nReturns\n\n\nThe updated vector after the element-wise subtraction.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\nmuleq()\n\n\nA vector can be scaled in-place with a number.\n\n\nlocal foo = luacml.vector3(1,2,3)\nprint(foo:muleq(2)) -- prints: vector3:\n2,4,6\n\nprint(foo)          -- prints: vector3:\n2,4,6\n\n\n\n\n\nNote\n\n\nThe original vector (not the parameter) is updated.\n\n\nParameters\n\n\nA scalar number.\n\n\nReturns\n\n\nThe updated vector after the element-wise multiplication.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\ndiveq()\n\n\nA vector can be inverse-scaled with a number.\n\n\nlocal foo = luacml.vector3(2,4,6)\nprint(foo:diveq(2)) -- prints: vector3:\n1,2,3\n\nprint(foo)          -- prints: vector3:\n1,2,3\n\n\n\n\n\nNote\n\n\nThe original vector (not the parameter) is updated.\n\n\nParameters\n\n\nA scalar number.\n\n\nReturns\n\n\nThe updated vector after the element-wise division.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nExtra arguments.\n\n\nInvalid argument type.\n\n\n\n\n\n\nVector metamethods\n\n\nAll vector types have a set of\n\nmetamethods\n that allow them to\nbe used with several operators.\n\n\n\n\n__index\n\n\nThe __index metamethod permits vector element access.\n\n\nVectors can be indexed with 1-based integer keys:\n\n\nlocal foo = luacml.vector2(10,20)\nprint(foo[1]) -- prints: 10\n\n\n\n\nOr with case-insensitive \"x\", \"y\", \"z\", or \"w\" string keys:\n\n\nlocal foo = luacml.vector3(10,20,30)\nprint(foo.x)    -- prints: 10\nprint(foo.Y)    -- prints: 20\nprint(foo[\nz\n]) -- prints: 30\n\n\n\n\nNote\n\n\nFor the following vector types, only the following keys are valid:\n\n\n\n\n\n\n\n\nVector Type\n\n\nValid Keys\n\n\n\n\n\n\n\n\n\n\nvector2\n\n\n1, 2, x, y\n\n\n\n\n\n\nvector3\n\n\n1, 2, 3, x, y, z\n\n\n\n\n\n\nvector4\n\n\n1, 2, 3, 4, x, y, z, w\n\n\n\n\n\n\n\n\nParameters\n\n\n\n\nAn integer from 1 to \nN\n\n\nor one of {x, y, z, w}, depending on vector size. See note above.\n\n\n\n\nReturns\n\n\nThe vector's element as a number.\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nInvalid index value.\n\n\nInvalid index type.\n\n\n\n\n\n\n__newindex\n\n\nThe __newindex metamethod permits vector element setting.\n\n\nVectors can be indexed with 1-based integer keys:\n\n\nlocal foo = luacml.vector2()\nfoo[1] = 10\n\n\n\n\nOr with case-insensitive \"x\", \"y\", \"z\", or \"w\" string keys:\n\n\nlocal foo = luacml.vector3()\nfoo.x = 10\nfoo.Y = 20\nfoo[\nz\n] = 30\n\n\n\n\nNote\n\n\nFor the following vector types, only the following keys are valid:\n\n\n\n\n\n\n\n\nVector Type\n\n\nValid Keys\n\n\n\n\n\n\n\n\n\n\nvector2\n\n\n1, 2, x, y\n\n\n\n\n\n\nvector3\n\n\n1, 2, 3, x, y, z\n\n\n\n\n\n\nvector4\n\n\n1, 2, 3, 4, x, y, z, w\n\n\n\n\n\n\n\n\nParameters\n\n\n\n\nAn integer from 1 to \nN\n\n\nor one of {x, y, z, w}, depending on vector size. See note above.\n\n\n\n\nReturns\n\n\n(None)\n\n\nErrors\n\n\n\n\nMissing arguments.\n\n\nInvalid index value.\n\n\nInvalid index type.\n\n\n\n\n\n\n__tostring\n\n\nVectors can be converted to strings for easy printing.\n\n\nlocal foo = luacml.vector2(1,2)\nprint(foo) -- prints: vector2:\n1,2\n\n\n\n\n\nlocal foo = luacml.vector4(1,2,3,4)\nprint(foo) -- prints: vector4:\n1,2,3,4\n\n\n\n\n\nNote\n\n\nThis function internally uses \nlua_pushfstring\n to format the output, so be\naware of different formatting across versions of Lua.\n\n\nParameters\n\n\nA vector.\n\n\nReturns\n\n\nThe vector formatted as a string.\n\n\nErrors\n\n\n(None)\n\n\n\n\n__unm\n\n\nThe negative of a vector can be generated.\n\n\nlocal foo = luacml.vector3(1,2,-3)\nprint(-foo) -- prints: vector3:\n-1,-2,3\n\n\n\n\n\nNote\n\n\nThe original vector is unchanged.\n\n\nParameters\n\n\nA vector.\n\n\nReturns\n\n\nA new vector representing the negative of the original.\n\n\nErrors\n\n\n(None)\n\n\n\n\n__add\n\n\nTwo vectors can be added together.\n\n\nlocal foo = luacml.vector3(1,2,3)\nlocal bar = luacml.vector3(3,2,1)\nprint(foo + bar) -- prints: vector3\n4,4,4\n\n\n\n\n\nNote\n\n\nThe original vectors are unchanged.\n\n\nParameters\n\n\nTwo vectors of same type.\n\n\nReturns\n\n\nA new vector representing the element-wise sum.\n\n\nErrors\n\n\n\n\nInvalid types.\n\n\n\n\n\n\n__sub\n\n\nTwo vectors can be subtracted.\n\n\nlocal foo = luacml.vector3(1,2,3)\nlocal bar = luacml.vector3(3,2,1)\nprint(foo - bar) -- prints: vector3\n-2,0,2\n\n\n\n\n\nNote\n\n\nThe original vectors are unchanged.\n\n\nParameters\n\n\nTwo vectors of same type.\n\n\nReturns\n\n\nA new vector representing the element-wise difference.\n\n\nErrors\n\n\n\n\nInvalid types.\n\n\n\n\n\n\n__mul\n\n\nVectors can be scaled.\n\n\nlocal foo = luacml.vector3(1,2,3)\nprint(2.0 * foo) -- prints: vector3\n2,4,6\n\nprint(foo * 3.0) -- prints: vector3\n3,6,9\n\n\n\n\n\nNote\n\n\nThe original vector is unchanged.\n\n\nParameters\n\n\nA vector and a number, in either order.\n\n\nReturns\n\n\nA new vector representing the element-wise scale.\n\n\nErrors\n\n\n\n\nInvalid types.\n\n\n\n\n\n\n__div\n\n\nVectors can be inverse divided.\n\n\nlocal foo = luacml.vector3(2,4,6)\nprint(foo / 2.0) -- prints: vector3\n1,2,3\n\n\n\n\n\nNote\n\n\nThe original vector is unchanged.\n\n\nParameters\n\n\nA vector and a number.\n\n\nReturns\n\n\nA new vector representing the element-wise division.\n\n\nErrors\n\n\n\n\nInvalid types.\n\n\n\n\n\n\n__eq\n\n\nVectors can be compared.\n\n\nlocal foo = luacml.vector3(2,4,6)\nlocal bar = luacml.vector3(2,4,6)\nprint(foo == bar) -- prints: true\n\n\n\n\nNote\n\n\nThe original vectors are unchanged.\n\n\nParameters\n\n\nTwo vectors of same type.\n\n\nReturns\n\n\nBoolean represent element-wise equality.\n\n\nErrors\n\n\n\n\nInvalid types.", 
            "title": "Vector docs"
        }, 
        {
            "location": "/vector-docs/#vectors", 
            "text": "", 
            "title": "Vectors"
        }, 
        {
            "location": "/vector-docs/#vector-types", 
            "text": "The following vector types are provided by LuaCML:     Type  Description      vector2  A two-element vector based on  lua_Number    vector3  A three-element vector based on  lua_Number    vector4  A four-element vector based on  lua_Number", 
            "title": "Vector types"
        }, 
        {
            "location": "/vector-docs/#vector-functions", 
            "text": "", 
            "title": "Vector functions"
        }, 
        {
            "location": "/vector-docs/#constructor", 
            "text": "Vectors have default constructors initialized with zeros:  local foo = luacml.vector3() -- set to (0,0,0)  Vectors can be constructed from individual numbers:  local foo = luacml.vector4(1,2,3,4)  Or from a table of numbers:  local foo = luacml.vector2({1,2})  Or from another vector:  local foo = luacml.vector3(1,2,3)\nlocal bar = luacml.vector3(foo) -- set to (1,2,3)", 
            "title": "constructor"
        }, 
        {
            "location": "/vector-docs/#parameters", 
            "text": "N  numbers.  or table of  N  numbers.  or a vector of size  N .", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns", 
            "text": "The newly constructed vector.", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#set", 
            "text": "Vectors can be set from individual numbers:  local foo = luacml.vector3()\nfoo:set(1,2,3)  Or from a table of numbers:  local foo = luacml.vector3()\nfoo:set({1,2,3})  Or from another vector:  local foo = luacml.vector3()\nfoo:set(luacml.vector3(1,2,3))", 
            "title": "set()"
        }, 
        {
            "location": "/vector-docs/#parameters_1", 
            "text": "N  numbers.  or table of  N  numbers.  or a vector of size  N .", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_1", 
            "text": "The vector, after it has been set.", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_1", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#totable", 
            "text": "Vectors can be converted to a table:  local foo = luacml.vector3(1,2,3)\nlocal bar = foo:totable()\nprint(bar[1], bar[2], bar[3]) -- prints: 1 2 3", 
            "title": "totable()"
        }, 
        {
            "location": "/vector-docs/#parameters_2", 
            "text": "(None)", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_2", 
            "text": "An array containing the vector's elements.", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_2", 
            "text": "Extra arguments.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#length", 
            "text": "The length of a vector can be found:  local foo = luacml.vector3(1,2,3)\nprint(foo:length())", 
            "title": "length()"
        }, 
        {
            "location": "/vector-docs/#parameters_3", 
            "text": "(None)", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_3", 
            "text": "The vector's length as a number.", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_3", 
            "text": "Extra arguments.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#length_squared", 
            "text": "The squared-length of a vector can be found:  local foo = luacml.vector3(1,2,3)\nprint(foo:length_squared())", 
            "title": "length_squared()"
        }, 
        {
            "location": "/vector-docs/#parameters_4", 
            "text": "(None)", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_4", 
            "text": "The vector's squared length as a number.", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_4", 
            "text": "Extra arguments.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#normalize", 
            "text": "A vector can be normalized in-place:  local foo = luacml.vector3(1,2,3)\nfoo:normalize()", 
            "title": "normalize()"
        }, 
        {
            "location": "/vector-docs/#parameters_5", 
            "text": "(None)", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_5", 
            "text": "The vector, after it has been normalized.", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_5", 
            "text": "Extra arguments.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#zero", 
            "text": "A vector can be zeroed in-place:  local foo = luacml.vector3(1,2,3)\nfoo:zero()", 
            "title": "zero()"
        }, 
        {
            "location": "/vector-docs/#parameters_6", 
            "text": "(None)", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_6", 
            "text": "The vector, after it has been zeroed.", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_6", 
            "text": "Extra arguments.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#cardinal", 
            "text": "A vector can be set to a cardinal axis:  local foo = luacml.vector3(1,2,3)\nfoo:cardinal(1) -- sets to  1,0,0 \nfoo:cardinal(2) -- sets to  0,1,0 \nfoo:cardinal(3) -- sets to  0,0,1", 
            "title": "cardinal()"
        }, 
        {
            "location": "/vector-docs/#parameters_7", 
            "text": "An integer from 1 to  N  for a vector of size  N .", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_7", 
            "text": "The vector, after it has been set.", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_7", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#minimize", 
            "text": "A vector can be set to the element-wise minimum of itself and another vector.  local foo = luacml.vector3(10,20,30)\nlocal bar = luacml.vector3(1,200,29)\nfoo:minimize(bar) -- sets to  1,20,29", 
            "title": "minimize()"
        }, 
        {
            "location": "/vector-docs/#parameters_8", 
            "text": "A vector of same size.", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_8", 
            "text": "(None)", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_8", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#maximize", 
            "text": "A vector can be set to the element-wise maximum of itself and another vector.  local foo = luacml.vector3(10,20,30)\nlocal bar = luacml.vector3(1,200,29)\nfoo:maximize(bar) -- sets to  10,200,30", 
            "title": "maximize()"
        }, 
        {
            "location": "/vector-docs/#parameters_9", 
            "text": "A vector of same size.", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_9", 
            "text": "(None)", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_9", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#random", 
            "text": "A vector can be set to a random vector with elements between specified minimum\nand maximum values.  local foo = luacml.vector3()\nfoo:random(-1,1) -- sets each element to a random value between -1 and 1.", 
            "title": "random()"
        }, 
        {
            "location": "/vector-docs/#parameters_10", 
            "text": "The minimum number.  The maximum number.", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_10", 
            "text": "(None)", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_10", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#add", 
            "text": "A vector can be added with another vector.  local foo = luacml.vector3(1,2,3)\nlocal bar = luacml.vector3(1,2,3)\nprint(foo:add(bar)) -- prints: vector3: 2,4,6 \nprint(foo)          -- prints: vector3: 1,2,3", 
            "title": "add()"
        }, 
        {
            "location": "/vector-docs/#note", 
            "text": "The original vectors are unchanged.  Internally, this equivalent to the  __add  metamethod.", 
            "title": "Note"
        }, 
        {
            "location": "/vector-docs/#parameters_11", 
            "text": "A vector of same type.", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_11", 
            "text": "A new vector representing the element-wise sum.", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_11", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#sub", 
            "text": "A vector can be added with another vector.  local foo = luacml.vector3(1,2,3)\nlocal bar = luacml.vector3(1,2,3)\nprint(foo:sub(bar)) -- prints: vector3: 0,0,0 \nprint(foo)          -- prints: vector3: 1,2,3", 
            "title": "sub()"
        }, 
        {
            "location": "/vector-docs/#note_1", 
            "text": "The original vectors are unchanged.  Internally, this function is equivalent to the  __sub  metamethod.", 
            "title": "Note"
        }, 
        {
            "location": "/vector-docs/#parameters_12", 
            "text": "A vector of same type.", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_12", 
            "text": "A new vector representing the element-wise difference.", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_12", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#mul", 
            "text": "A vector can be scaled with a number.  local foo = luacml.vector3(1,2,3)\nprint(foo:mul(2)) -- prints: vector3: 2,4,6 \nprint(foo)        -- prints: vector3: 1,2,3", 
            "title": "mul()"
        }, 
        {
            "location": "/vector-docs/#note_2", 
            "text": "The original vector is unchanged.  Internally, this function is equivalent to the  __mul  metamethod.", 
            "title": "Note"
        }, 
        {
            "location": "/vector-docs/#parameters_13", 
            "text": "A scalar number.", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_13", 
            "text": "A new vector representing the element-wise scale.", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_13", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#div", 
            "text": "A vector can be inverse-scaled with a number.  local foo = luacml.vector3(2,4,6)\nprint(foo:div(2)) -- prints: vector3: 1,2,3 \nprint(foo)        -- prints: vector3: 2,4,6", 
            "title": "div()"
        }, 
        {
            "location": "/vector-docs/#note_3", 
            "text": "The original vector is unchanged.  Internally, this function is equivalent to the  __div  metamethod.", 
            "title": "Note"
        }, 
        {
            "location": "/vector-docs/#parameters_14", 
            "text": "A scalar number.", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_14", 
            "text": "A new vector representing the element-wise division.", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_14", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#addeq", 
            "text": "A vector can be incremented in-place with another vector.  local foo = luacml.vector3(1,2,3)\nlocal bar = luacml.vector3(1,2,3)\nprint(foo:addeq(bar)) -- prints: vector3: 2,4,6 \nprint(foo)            -- prints: vector3: 2,4,6", 
            "title": "addeq()"
        }, 
        {
            "location": "/vector-docs/#note_4", 
            "text": "The original vector (not the parameter) is updated.", 
            "title": "Note"
        }, 
        {
            "location": "/vector-docs/#parameters_15", 
            "text": "A vector of same type.", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_15", 
            "text": "The updated vector after the element-wise sum.", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_15", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#subeq", 
            "text": "A vector can be subtracted in-place with another vector.  local foo = luacml.vector3(1,2,3)\nlocal bar = luacml.vector3(1,2,3)\nprint(foo:subeq(bar)) -- prints: vector3: 0,0,0 \nprint(foo)            -- prints: vector3: 0,0,0", 
            "title": "subeq()"
        }, 
        {
            "location": "/vector-docs/#note_5", 
            "text": "The original vector (not the parameter) is updated.", 
            "title": "Note"
        }, 
        {
            "location": "/vector-docs/#parameters_16", 
            "text": "A vector of same type.", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_16", 
            "text": "The updated vector after the element-wise subtraction.", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_16", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#muleq", 
            "text": "A vector can be scaled in-place with a number.  local foo = luacml.vector3(1,2,3)\nprint(foo:muleq(2)) -- prints: vector3: 2,4,6 \nprint(foo)          -- prints: vector3: 2,4,6", 
            "title": "muleq()"
        }, 
        {
            "location": "/vector-docs/#note_6", 
            "text": "The original vector (not the parameter) is updated.", 
            "title": "Note"
        }, 
        {
            "location": "/vector-docs/#parameters_17", 
            "text": "A scalar number.", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_17", 
            "text": "The updated vector after the element-wise multiplication.", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_17", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#diveq", 
            "text": "A vector can be inverse-scaled with a number.  local foo = luacml.vector3(2,4,6)\nprint(foo:diveq(2)) -- prints: vector3: 1,2,3 \nprint(foo)          -- prints: vector3: 1,2,3", 
            "title": "diveq()"
        }, 
        {
            "location": "/vector-docs/#note_7", 
            "text": "The original vector (not the parameter) is updated.", 
            "title": "Note"
        }, 
        {
            "location": "/vector-docs/#parameters_18", 
            "text": "A scalar number.", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_18", 
            "text": "The updated vector after the element-wise division.", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_18", 
            "text": "Missing arguments.  Extra arguments.  Invalid argument type.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#vector-metamethods", 
            "text": "All vector types have a set of metamethods  that allow them to\nbe used with several operators.", 
            "title": "Vector metamethods"
        }, 
        {
            "location": "/vector-docs/#__index", 
            "text": "The __index metamethod permits vector element access.  Vectors can be indexed with 1-based integer keys:  local foo = luacml.vector2(10,20)\nprint(foo[1]) -- prints: 10  Or with case-insensitive \"x\", \"y\", \"z\", or \"w\" string keys:  local foo = luacml.vector3(10,20,30)\nprint(foo.x)    -- prints: 10\nprint(foo.Y)    -- prints: 20\nprint(foo[ z ]) -- prints: 30", 
            "title": "__index"
        }, 
        {
            "location": "/vector-docs/#note_8", 
            "text": "For the following vector types, only the following keys are valid:     Vector Type  Valid Keys      vector2  1, 2, x, y    vector3  1, 2, 3, x, y, z    vector4  1, 2, 3, 4, x, y, z, w", 
            "title": "Note"
        }, 
        {
            "location": "/vector-docs/#parameters_19", 
            "text": "An integer from 1 to  N  or one of {x, y, z, w}, depending on vector size. See note above.", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_19", 
            "text": "The vector's element as a number.", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_19", 
            "text": "Missing arguments.  Invalid index value.  Invalid index type.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#__newindex", 
            "text": "The __newindex metamethod permits vector element setting.  Vectors can be indexed with 1-based integer keys:  local foo = luacml.vector2()\nfoo[1] = 10  Or with case-insensitive \"x\", \"y\", \"z\", or \"w\" string keys:  local foo = luacml.vector3()\nfoo.x = 10\nfoo.Y = 20\nfoo[ z ] = 30", 
            "title": "__newindex"
        }, 
        {
            "location": "/vector-docs/#note_9", 
            "text": "For the following vector types, only the following keys are valid:     Vector Type  Valid Keys      vector2  1, 2, x, y    vector3  1, 2, 3, x, y, z    vector4  1, 2, 3, 4, x, y, z, w", 
            "title": "Note"
        }, 
        {
            "location": "/vector-docs/#parameters_20", 
            "text": "An integer from 1 to  N  or one of {x, y, z, w}, depending on vector size. See note above.", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_20", 
            "text": "(None)", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_20", 
            "text": "Missing arguments.  Invalid index value.  Invalid index type.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#__tostring", 
            "text": "Vectors can be converted to strings for easy printing.  local foo = luacml.vector2(1,2)\nprint(foo) -- prints: vector2: 1,2   local foo = luacml.vector4(1,2,3,4)\nprint(foo) -- prints: vector4: 1,2,3,4", 
            "title": "__tostring"
        }, 
        {
            "location": "/vector-docs/#note_10", 
            "text": "This function internally uses  lua_pushfstring  to format the output, so be\naware of different formatting across versions of Lua.", 
            "title": "Note"
        }, 
        {
            "location": "/vector-docs/#parameters_21", 
            "text": "A vector.", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_21", 
            "text": "The vector formatted as a string.", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_21", 
            "text": "(None)", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#__unm", 
            "text": "The negative of a vector can be generated.  local foo = luacml.vector3(1,2,-3)\nprint(-foo) -- prints: vector3: -1,-2,3", 
            "title": "__unm"
        }, 
        {
            "location": "/vector-docs/#note_11", 
            "text": "The original vector is unchanged.", 
            "title": "Note"
        }, 
        {
            "location": "/vector-docs/#parameters_22", 
            "text": "A vector.", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_22", 
            "text": "A new vector representing the negative of the original.", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_22", 
            "text": "(None)", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#__add", 
            "text": "Two vectors can be added together.  local foo = luacml.vector3(1,2,3)\nlocal bar = luacml.vector3(3,2,1)\nprint(foo + bar) -- prints: vector3 4,4,4", 
            "title": "__add"
        }, 
        {
            "location": "/vector-docs/#note_12", 
            "text": "The original vectors are unchanged.", 
            "title": "Note"
        }, 
        {
            "location": "/vector-docs/#parameters_23", 
            "text": "Two vectors of same type.", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_23", 
            "text": "A new vector representing the element-wise sum.", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_23", 
            "text": "Invalid types.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#__sub", 
            "text": "Two vectors can be subtracted.  local foo = luacml.vector3(1,2,3)\nlocal bar = luacml.vector3(3,2,1)\nprint(foo - bar) -- prints: vector3 -2,0,2", 
            "title": "__sub"
        }, 
        {
            "location": "/vector-docs/#note_13", 
            "text": "The original vectors are unchanged.", 
            "title": "Note"
        }, 
        {
            "location": "/vector-docs/#parameters_24", 
            "text": "Two vectors of same type.", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_24", 
            "text": "A new vector representing the element-wise difference.", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_24", 
            "text": "Invalid types.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#__mul", 
            "text": "Vectors can be scaled.  local foo = luacml.vector3(1,2,3)\nprint(2.0 * foo) -- prints: vector3 2,4,6 \nprint(foo * 3.0) -- prints: vector3 3,6,9", 
            "title": "__mul"
        }, 
        {
            "location": "/vector-docs/#note_14", 
            "text": "The original vector is unchanged.", 
            "title": "Note"
        }, 
        {
            "location": "/vector-docs/#parameters_25", 
            "text": "A vector and a number, in either order.", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_25", 
            "text": "A new vector representing the element-wise scale.", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_25", 
            "text": "Invalid types.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#__div", 
            "text": "Vectors can be inverse divided.  local foo = luacml.vector3(2,4,6)\nprint(foo / 2.0) -- prints: vector3 1,2,3", 
            "title": "__div"
        }, 
        {
            "location": "/vector-docs/#note_15", 
            "text": "The original vector is unchanged.", 
            "title": "Note"
        }, 
        {
            "location": "/vector-docs/#parameters_26", 
            "text": "A vector and a number.", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_26", 
            "text": "A new vector representing the element-wise division.", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_26", 
            "text": "Invalid types.", 
            "title": "Errors"
        }, 
        {
            "location": "/vector-docs/#__eq", 
            "text": "Vectors can be compared.  local foo = luacml.vector3(2,4,6)\nlocal bar = luacml.vector3(2,4,6)\nprint(foo == bar) -- prints: true", 
            "title": "__eq"
        }, 
        {
            "location": "/vector-docs/#note_16", 
            "text": "The original vectors are unchanged.", 
            "title": "Note"
        }, 
        {
            "location": "/vector-docs/#parameters_27", 
            "text": "Two vectors of same type.", 
            "title": "Parameters"
        }, 
        {
            "location": "/vector-docs/#returns_27", 
            "text": "Boolean represent element-wise equality.", 
            "title": "Returns"
        }, 
        {
            "location": "/vector-docs/#errors_27", 
            "text": "Invalid types.", 
            "title": "Errors"
        }
    ]
}